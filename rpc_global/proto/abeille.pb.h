// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: abeille.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_abeille_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_abeille_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_abeille_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_abeille_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_abeille_2eproto;
class AddRequest;
struct AddRequestDefaultTypeInternal;
extern AddRequestDefaultTypeInternal _AddRequest_default_instance_;
class AppendEntryRequest;
struct AppendEntryRequestDefaultTypeInternal;
extern AppendEntryRequestDefaultTypeInternal _AppendEntryRequest_default_instance_;
class AppendEntryResponse;
struct AppendEntryResponseDefaultTypeInternal;
extern AppendEntryResponseDefaultTypeInternal _AppendEntryResponse_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Entry;
struct EntryDefaultTypeInternal;
extern EntryDefaultTypeInternal _Entry_default_instance_;
class MoveRequest;
struct MoveRequestDefaultTypeInternal;
extern MoveRequestDefaultTypeInternal _MoveRequest_default_instance_;
class RaftConfig;
struct RaftConfigDefaultTypeInternal;
extern RaftConfigDefaultTypeInternal _RaftConfig_default_instance_;
class RequestVoteRequest;
struct RequestVoteRequestDefaultTypeInternal;
extern RequestVoteRequestDefaultTypeInternal _RequestVoteRequest_default_instance_;
class RequestVoteResponse;
struct RequestVoteResponseDefaultTypeInternal;
extern RequestVoteResponseDefaultTypeInternal _RequestVoteResponse_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskData;
struct TaskDataDefaultTypeInternal;
extern TaskDataDefaultTypeInternal _TaskData_default_instance_;
class TaskResult;
struct TaskResultDefaultTypeInternal;
extern TaskResultDefaultTypeInternal _TaskResult_default_instance_;
class TaskState;
struct TaskStateDefaultTypeInternal;
extern TaskStateDefaultTypeInternal _TaskState_default_instance_;
class UserConnectRequest;
struct UserConnectRequestDefaultTypeInternal;
extern UserConnectRequestDefaultTypeInternal _UserConnectRequest_default_instance_;
class UserConnectResponse;
struct UserConnectResponseDefaultTypeInternal;
extern UserConnectResponseDefaultTypeInternal _UserConnectResponse_default_instance_;
class WorkerConnectRequest;
struct WorkerConnectRequestDefaultTypeInternal;
extern WorkerConnectRequestDefaultTypeInternal _WorkerConnectRequest_default_instance_;
class WorkerConnectResponse;
struct WorkerConnectResponseDefaultTypeInternal;
extern WorkerConnectResponseDefaultTypeInternal _WorkerConnectResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AddRequest* Arena::CreateMaybeMessage<::AddRequest>(Arena*);
template<> ::AppendEntryRequest* Arena::CreateMaybeMessage<::AppendEntryRequest>(Arena*);
template<> ::AppendEntryResponse* Arena::CreateMaybeMessage<::AppendEntryResponse>(Arena*);
template<> ::DeleteRequest* Arena::CreateMaybeMessage<::DeleteRequest>(Arena*);
template<> ::Empty* Arena::CreateMaybeMessage<::Empty>(Arena*);
template<> ::Entry* Arena::CreateMaybeMessage<::Entry>(Arena*);
template<> ::MoveRequest* Arena::CreateMaybeMessage<::MoveRequest>(Arena*);
template<> ::RaftConfig* Arena::CreateMaybeMessage<::RaftConfig>(Arena*);
template<> ::RequestVoteRequest* Arena::CreateMaybeMessage<::RequestVoteRequest>(Arena*);
template<> ::RequestVoteResponse* Arena::CreateMaybeMessage<::RequestVoteResponse>(Arena*);
template<> ::Task* Arena::CreateMaybeMessage<::Task>(Arena*);
template<> ::TaskData* Arena::CreateMaybeMessage<::TaskData>(Arena*);
template<> ::TaskResult* Arena::CreateMaybeMessage<::TaskResult>(Arena*);
template<> ::TaskState* Arena::CreateMaybeMessage<::TaskState>(Arena*);
template<> ::UserConnectRequest* Arena::CreateMaybeMessage<::UserConnectRequest>(Arena*);
template<> ::UserConnectResponse* Arena::CreateMaybeMessage<::UserConnectResponse>(Arena*);
template<> ::WorkerConnectRequest* Arena::CreateMaybeMessage<::WorkerConnectRequest>(Arena*);
template<> ::WorkerConnectResponse* Arena::CreateMaybeMessage<::WorkerConnectResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum UserStatus : int {
  USER_STATUS_DOWN = 0,
  USER_STATUS_IDLE = 1,
  USER_STATUS_UPLOAD_DATA = 2,
  UserStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserStatus_IsValid(int value);
constexpr UserStatus UserStatus_MIN = USER_STATUS_DOWN;
constexpr UserStatus UserStatus_MAX = USER_STATUS_UPLOAD_DATA;
constexpr int UserStatus_ARRAYSIZE = UserStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserStatus_descriptor();
template<typename T>
inline const std::string& UserStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserStatus_descriptor(), enum_t_value);
}
inline bool UserStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserStatus>(
    UserStatus_descriptor(), name, value);
}
enum UserCommand : int {
  USER_COMMAND_NONE = 0,
  USER_COMMAND_REDIRECT = 1,
  USER_COMMAND_ASSIGN = 2,
  USER_COMMAND_RESULT = 3,
  UserCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserCommand_IsValid(int value);
constexpr UserCommand UserCommand_MIN = USER_COMMAND_NONE;
constexpr UserCommand UserCommand_MAX = USER_COMMAND_RESULT;
constexpr int UserCommand_ARRAYSIZE = UserCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserCommand_descriptor();
template<typename T>
inline const std::string& UserCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserCommand_descriptor(), enum_t_value);
}
inline bool UserCommand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserCommand>(
    UserCommand_descriptor(), name, value);
}
enum TaskStatus : int {
  TASK_STATUS_UNASSIGNED = 0,
  TASK_STATUS_ASSIGNED = 1,
  TASK_STATUS_COMPLETED = 2,
  TaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskStatus_IsValid(int value);
constexpr TaskStatus TaskStatus_MIN = TASK_STATUS_UNASSIGNED;
constexpr TaskStatus TaskStatus_MAX = TASK_STATUS_COMPLETED;
constexpr int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskStatus_descriptor();
template<typename T>
inline const std::string& TaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskStatus_descriptor(), enum_t_value);
}
inline bool TaskStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskStatus>(
    TaskStatus_descriptor(), name, value);
}
enum RaftCommand : int {
  RAFT_COMMAND_ADD = 0,
  RAFT_COMMAND_MOVE = 1,
  RAFT_COMMAND_DELETE = 2,
  RaftCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RaftCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RaftCommand_IsValid(int value);
constexpr RaftCommand RaftCommand_MIN = RAFT_COMMAND_ADD;
constexpr RaftCommand RaftCommand_MAX = RAFT_COMMAND_DELETE;
constexpr int RaftCommand_ARRAYSIZE = RaftCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RaftCommand_descriptor();
template<typename T>
inline const std::string& RaftCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RaftCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RaftCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RaftCommand_descriptor(), enum_t_value);
}
inline bool RaftCommand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RaftCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RaftCommand>(
    RaftCommand_descriptor(), name, value);
}
enum WorkerStatus : int {
  WORKER_STATUS_DOWN = 0,
  WORKER_STATUS_IDLE = 1,
  WORKER_STATUS_BUSY = 2,
  WORKER_STATUS_COMPLETED = 3,
  WorkerStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkerStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkerStatus_IsValid(int value);
constexpr WorkerStatus WorkerStatus_MIN = WORKER_STATUS_DOWN;
constexpr WorkerStatus WorkerStatus_MAX = WORKER_STATUS_COMPLETED;
constexpr int WorkerStatus_ARRAYSIZE = WorkerStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkerStatus_descriptor();
template<typename T>
inline const std::string& WorkerStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkerStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkerStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkerStatus_descriptor(), enum_t_value);
}
inline bool WorkerStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkerStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkerStatus>(
    WorkerStatus_descriptor(), name, value);
}
enum WorkerCommand : int {
  WORKER_COMMAND_NONE = 0,
  WORKER_COMMAND_ASSIGN = 1,
  WORKER_COMMAND_PROCESS = 2,
  WORKER_COMMAND_REDIRECT = 3,
  WorkerCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkerCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkerCommand_IsValid(int value);
constexpr WorkerCommand WorkerCommand_MIN = WORKER_COMMAND_NONE;
constexpr WorkerCommand WorkerCommand_MAX = WORKER_COMMAND_REDIRECT;
constexpr int WorkerCommand_ARRAYSIZE = WorkerCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkerCommand_descriptor();
template<typename T>
inline const std::string& WorkerCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkerCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkerCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkerCommand_descriptor(), enum_t_value);
}
inline bool WorkerCommand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkerCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkerCommand>(
    WorkerCommand_descriptor(), name, value);
}
// ===================================================================

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  ~Empty() override;
  explicit constexpr Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return new Empty();
  }

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Empty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Empty& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class TaskData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskData) */ {
 public:
  inline TaskData() : TaskData(nullptr) {}
  ~TaskData() override;
  explicit constexpr TaskData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskData(const TaskData& from);
  TaskData(TaskData&& from) noexcept
    : TaskData() {
    *this = ::std::move(from);
  }

  inline TaskData& operator=(const TaskData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskData& operator=(TaskData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskData* internal_default_instance() {
    return reinterpret_cast<const TaskData*>(
               &_TaskData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TaskData& a, TaskData& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskData* New() const final {
    return new TaskData();
  }

  TaskData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskData";
  }
  protected:
  explicit TaskData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated int32 data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_data() const;
  void _internal_add_data(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_data();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 data(int index) const;
  void set_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_data(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:TaskData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class TaskResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskResult) */ {
 public:
  inline TaskResult() : TaskResult(nullptr) {}
  ~TaskResult() override;
  explicit constexpr TaskResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskResult(const TaskResult& from);
  TaskResult(TaskResult&& from) noexcept
    : TaskResult() {
    *this = ::std::move(from);
  }

  inline TaskResult& operator=(const TaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskResult& operator=(TaskResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskResult* internal_default_instance() {
    return reinterpret_cast<const TaskResult*>(
               &_TaskResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TaskResult& a, TaskResult& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskResult* New() const final {
    return new TaskResult();
  }

  TaskResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskResult";
  }
  protected:
  explicit TaskResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // int32 result = 1;
  void clear_result();
  ::PROTOBUF_NAMESPACE_ID::int32 result() const;
  void set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_result() const;
  void _internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:TaskResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class TaskState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskState) */ {
 public:
  inline TaskState() : TaskState(nullptr) {}
  ~TaskState() override;
  explicit constexpr TaskState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskState(const TaskState& from);
  TaskState(TaskState&& from) noexcept
    : TaskState() {
    *this = ::std::move(from);
  }

  inline TaskState& operator=(const TaskState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskState& operator=(TaskState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskState& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskState* internal_default_instance() {
    return reinterpret_cast<const TaskState*>(
               &_TaskState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TaskState& a, TaskState& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskState* New() const final {
    return new TaskState();
  }

  TaskState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskState";
  }
  protected:
  explicit TaskState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskResultFieldNumber = 2,
    kTaskIdFieldNumber = 1,
  };
  // .TaskResult task_result = 2;
  bool has_task_result() const;
  private:
  bool _internal_has_task_result() const;
  public:
  void clear_task_result();
  const ::TaskResult& task_result() const;
  PROTOBUF_MUST_USE_RESULT ::TaskResult* release_task_result();
  ::TaskResult* mutable_task_result();
  void set_allocated_task_result(::TaskResult* task_result);
  private:
  const ::TaskResult& _internal_task_result() const;
  ::TaskResult* _internal_mutable_task_result();
  public:
  void unsafe_arena_set_allocated_task_result(
      ::TaskResult* task_result);
  ::TaskResult* unsafe_arena_release_task_result();

  // uint64 task_id = 1;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:TaskState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskResult* task_result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class UserConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserConnectRequest) */ {
 public:
  inline UserConnectRequest() : UserConnectRequest(nullptr) {}
  ~UserConnectRequest() override;
  explicit constexpr UserConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserConnectRequest(const UserConnectRequest& from);
  UserConnectRequest(UserConnectRequest&& from) noexcept
    : UserConnectRequest() {
    *this = ::std::move(from);
  }

  inline UserConnectRequest& operator=(const UserConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserConnectRequest& operator=(UserConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserConnectRequest* internal_default_instance() {
    return reinterpret_cast<const UserConnectRequest*>(
               &_UserConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserConnectRequest& a, UserConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserConnectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserConnectRequest* New() const final {
    return new UserConnectRequest();
  }

  UserConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserConnectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserConnectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserConnectRequest";
  }
  protected:
  explicit UserConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskDataFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // .TaskData task_data = 2;
  bool has_task_data() const;
  private:
  bool _internal_has_task_data() const;
  public:
  void clear_task_data();
  const ::TaskData& task_data() const;
  PROTOBUF_MUST_USE_RESULT ::TaskData* release_task_data();
  ::TaskData* mutable_task_data();
  void set_allocated_task_data(::TaskData* task_data);
  private:
  const ::TaskData& _internal_task_data() const;
  ::TaskData* _internal_mutable_task_data();
  public:
  void unsafe_arena_set_allocated_task_data(
      ::TaskData* task_data);
  ::TaskData* unsafe_arena_release_task_data();

  // .UserStatus status = 1;
  void clear_status();
  ::UserStatus status() const;
  void set_status(::UserStatus value);
  private:
  ::UserStatus _internal_status() const;
  void _internal_set_status(::UserStatus value);
  public:

  // @@protoc_insertion_point(class_scope:UserConnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskData* task_data_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class UserConnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserConnectResponse) */ {
 public:
  inline UserConnectResponse() : UserConnectResponse(nullptr) {}
  ~UserConnectResponse() override;
  explicit constexpr UserConnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserConnectResponse(const UserConnectResponse& from);
  UserConnectResponse(UserConnectResponse&& from) noexcept
    : UserConnectResponse() {
    *this = ::std::move(from);
  }

  inline UserConnectResponse& operator=(const UserConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserConnectResponse& operator=(UserConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserConnectResponse* internal_default_instance() {
    return reinterpret_cast<const UserConnectResponse*>(
               &_UserConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UserConnectResponse& a, UserConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserConnectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserConnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserConnectResponse* New() const final {
    return new UserConnectResponse();
  }

  UserConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserConnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserConnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserConnectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserConnectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserConnectResponse";
  }
  protected:
  explicit UserConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskResultFieldNumber = 4,
    kLeaderIdFieldNumber = 2,
    kTaskIdFieldNumber = 3,
    kCommandFieldNumber = 1,
  };
  // .TaskResult task_result = 4;
  bool has_task_result() const;
  private:
  bool _internal_has_task_result() const;
  public:
  void clear_task_result();
  const ::TaskResult& task_result() const;
  PROTOBUF_MUST_USE_RESULT ::TaskResult* release_task_result();
  ::TaskResult* mutable_task_result();
  void set_allocated_task_result(::TaskResult* task_result);
  private:
  const ::TaskResult& _internal_task_result() const;
  ::TaskResult* _internal_mutable_task_result();
  public:
  void unsafe_arena_set_allocated_task_result(
      ::TaskResult* task_result);
  ::TaskResult* unsafe_arena_release_task_result();

  // uint64 leader_id = 2;
  void clear_leader_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id() const;
  void set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_id() const;
  void _internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 task_id = 3;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .UserCommand command = 1;
  void clear_command();
  ::UserCommand command() const;
  void set_command(::UserCommand value);
  private:
  ::UserCommand _internal_command() const;
  void _internal_set_command(::UserCommand value);
  public:

  // @@protoc_insertion_point(class_scope:UserConnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskResult* task_result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class Task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  explicit constexpr Task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Task* New() const final {
    return new Task();
  }

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Task& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskDataFieldNumber = 3,
    kTaskResultFieldNumber = 4,
    kIdFieldNumber = 1,
    kWorkerIdFieldNumber = 2,
  };
  // .TaskData task_data = 3;
  bool has_task_data() const;
  private:
  bool _internal_has_task_data() const;
  public:
  void clear_task_data();
  const ::TaskData& task_data() const;
  PROTOBUF_MUST_USE_RESULT ::TaskData* release_task_data();
  ::TaskData* mutable_task_data();
  void set_allocated_task_data(::TaskData* task_data);
  private:
  const ::TaskData& _internal_task_data() const;
  ::TaskData* _internal_mutable_task_data();
  public:
  void unsafe_arena_set_allocated_task_data(
      ::TaskData* task_data);
  ::TaskData* unsafe_arena_release_task_data();

  // .TaskResult task_result = 4;
  bool has_task_result() const;
  private:
  bool _internal_has_task_result() const;
  public:
  void clear_task_result();
  const ::TaskResult& task_result() const;
  PROTOBUF_MUST_USE_RESULT ::TaskResult* release_task_result();
  ::TaskResult* mutable_task_result();
  void set_allocated_task_result(::TaskResult* task_result);
  private:
  const ::TaskResult& _internal_task_result() const;
  ::TaskResult* _internal_mutable_task_result();
  public:
  void unsafe_arena_set_allocated_task_result(
      ::TaskResult* task_result);
  ::TaskResult* unsafe_arena_release_task_result();

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 worker_id = 2;
  void clear_worker_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 worker_id() const;
  void set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_worker_id() const;
  void _internal_set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskData* task_data_;
  ::TaskResult* task_result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 worker_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class AddRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AddRequest) */ {
 public:
  inline AddRequest() : AddRequest(nullptr) {}
  ~AddRequest() override;
  explicit constexpr AddRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddRequest(const AddRequest& from);
  AddRequest(AddRequest&& from) noexcept
    : AddRequest() {
    *this = ::std::move(from);
  }

  inline AddRequest& operator=(const AddRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddRequest& operator=(AddRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddRequest* internal_default_instance() {
    return reinterpret_cast<const AddRequest*>(
               &_AddRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AddRequest& a, AddRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddRequest* New() const final {
    return new AddRequest();
  }

  AddRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AddRequest";
  }
  protected:
  explicit AddRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
  };
  // .TaskStatus to = 1;
  void clear_to();
  ::TaskStatus to() const;
  void set_to(::TaskStatus value);
  private:
  ::TaskStatus _internal_to() const;
  void _internal_set_to(::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:AddRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int to_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class MoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MoveRequest) */ {
 public:
  inline MoveRequest() : MoveRequest(nullptr) {}
  ~MoveRequest() override;
  explicit constexpr MoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveRequest(const MoveRequest& from);
  MoveRequest(MoveRequest&& from) noexcept
    : MoveRequest() {
    *this = ::std::move(from);
  }

  inline MoveRequest& operator=(const MoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveRequest& operator=(MoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveRequest* internal_default_instance() {
    return reinterpret_cast<const MoveRequest*>(
               &_MoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MoveRequest& a, MoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveRequest* New() const final {
    return new MoveRequest();
  }

  MoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MoveRequest";
  }
  protected:
  explicit MoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
    kFromFieldNumber = 2,
  };
  // .TaskStatus to = 1;
  void clear_to();
  ::TaskStatus to() const;
  void set_to(::TaskStatus value);
  private:
  ::TaskStatus _internal_to() const;
  void _internal_set_to(::TaskStatus value);
  public:

  // .TaskStatus from = 2;
  void clear_from();
  ::TaskStatus from() const;
  void set_from(::TaskStatus value);
  private:
  ::TaskStatus _internal_from() const;
  void _internal_set_from(::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:MoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int to_;
  int from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit constexpr DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return new DeleteRequest();
  }

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
  };
  // .TaskStatus from = 1;
  void clear_from();
  ::TaskStatus from() const;
  void set_from(::TaskStatus value);
  private:
  ::TaskStatus _internal_from() const;
  void _internal_set_from(::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Entry) */ {
 public:
  inline Entry() : Entry(nullptr) {}
  ~Entry() override;
  explicit constexpr Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entry(const Entry& from);
  Entry(Entry&& from) noexcept
    : Entry() {
    *this = ::std::move(from);
  }

  inline Entry& operator=(const Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entry& operator=(Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entry* internal_default_instance() {
    return reinterpret_cast<const Entry*>(
               &_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Entry& a, Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(Entry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Entry* New() const final {
    return new Entry();
  }

  Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Entry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Entry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Entry";
  }
  protected:
  explicit Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 3,
    kAddRequestFieldNumber = 4,
    kMoveRequestFieldNumber = 5,
    kDeleteRequestFieldNumber = 6,
    kTermFieldNumber = 2,
    kCommandFieldNumber = 1,
  };
  // .Task task = 3;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::Task& task() const;
  PROTOBUF_MUST_USE_RESULT ::Task* release_task();
  ::Task* mutable_task();
  void set_allocated_task(::Task* task);
  private:
  const ::Task& _internal_task() const;
  ::Task* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::Task* task);
  ::Task* unsafe_arena_release_task();

  // .AddRequest add_request = 4;
  bool has_add_request() const;
  private:
  bool _internal_has_add_request() const;
  public:
  void clear_add_request();
  const ::AddRequest& add_request() const;
  PROTOBUF_MUST_USE_RESULT ::AddRequest* release_add_request();
  ::AddRequest* mutable_add_request();
  void set_allocated_add_request(::AddRequest* add_request);
  private:
  const ::AddRequest& _internal_add_request() const;
  ::AddRequest* _internal_mutable_add_request();
  public:
  void unsafe_arena_set_allocated_add_request(
      ::AddRequest* add_request);
  ::AddRequest* unsafe_arena_release_add_request();

  // .MoveRequest move_request = 5;
  bool has_move_request() const;
  private:
  bool _internal_has_move_request() const;
  public:
  void clear_move_request();
  const ::MoveRequest& move_request() const;
  PROTOBUF_MUST_USE_RESULT ::MoveRequest* release_move_request();
  ::MoveRequest* mutable_move_request();
  void set_allocated_move_request(::MoveRequest* move_request);
  private:
  const ::MoveRequest& _internal_move_request() const;
  ::MoveRequest* _internal_mutable_move_request();
  public:
  void unsafe_arena_set_allocated_move_request(
      ::MoveRequest* move_request);
  ::MoveRequest* unsafe_arena_release_move_request();

  // .DeleteRequest delete_request = 6;
  bool has_delete_request() const;
  private:
  bool _internal_has_delete_request() const;
  public:
  void clear_delete_request();
  const ::DeleteRequest& delete_request() const;
  PROTOBUF_MUST_USE_RESULT ::DeleteRequest* release_delete_request();
  ::DeleteRequest* mutable_delete_request();
  void set_allocated_delete_request(::DeleteRequest* delete_request);
  private:
  const ::DeleteRequest& _internal_delete_request() const;
  ::DeleteRequest* _internal_mutable_delete_request();
  public:
  void unsafe_arena_set_allocated_delete_request(
      ::DeleteRequest* delete_request);
  ::DeleteRequest* unsafe_arena_release_delete_request();

  // uint64 term = 2;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .RaftCommand command = 1;
  void clear_command();
  ::RaftCommand command() const;
  void set_command(::RaftCommand value);
  private:
  ::RaftCommand _internal_command() const;
  void _internal_set_command(::RaftCommand value);
  public:

  // @@protoc_insertion_point(class_scope:Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Task* task_;
  ::AddRequest* add_request_;
  ::MoveRequest* move_request_;
  ::DeleteRequest* delete_request_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class AppendEntryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AppendEntryRequest) */ {
 public:
  inline AppendEntryRequest() : AppendEntryRequest(nullptr) {}
  ~AppendEntryRequest() override;
  explicit constexpr AppendEntryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntryRequest(const AppendEntryRequest& from);
  AppendEntryRequest(AppendEntryRequest&& from) noexcept
    : AppendEntryRequest() {
    *this = ::std::move(from);
  }

  inline AppendEntryRequest& operator=(const AppendEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntryRequest& operator=(AppendEntryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntryRequest* internal_default_instance() {
    return reinterpret_cast<const AppendEntryRequest*>(
               &_AppendEntryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AppendEntryRequest& a, AppendEntryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppendEntryRequest* New() const final {
    return new AppendEntryRequest();
  }

  AppendEntryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppendEntryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AppendEntryRequest";
  }
  protected:
  explicit AppendEntryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 5,
    kTermFieldNumber = 1,
    kLeaderIdFieldNumber = 2,
    kPrevLogIndexFieldNumber = 3,
    kPrevLogTermFieldNumber = 4,
    kLeaderCommitFieldNumber = 6,
  };
  // .Entry entry = 5;
  bool has_entry() const;
  private:
  bool _internal_has_entry() const;
  public:
  void clear_entry();
  const ::Entry& entry() const;
  PROTOBUF_MUST_USE_RESULT ::Entry* release_entry();
  ::Entry* mutable_entry();
  void set_allocated_entry(::Entry* entry);
  private:
  const ::Entry& _internal_entry() const;
  ::Entry* _internal_mutable_entry();
  public:
  void unsafe_arena_set_allocated_entry(
      ::Entry* entry);
  ::Entry* unsafe_arena_release_entry();

  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 leader_id = 2;
  void clear_leader_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id() const;
  void set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_id() const;
  void _internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 prev_log_index = 3;
  void clear_prev_log_index();
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_index() const;
  void set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_prev_log_index() const;
  void _internal_set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 prev_log_term = 4;
  void clear_prev_log_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_term() const;
  void set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_prev_log_term() const;
  void _internal_set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 leader_commit = 6;
  void clear_leader_commit();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_commit() const;
  void set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_commit() const;
  void _internal_set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:AppendEntryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Entry* entry_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_index_;
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_term_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_commit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class AppendEntryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AppendEntryResponse) */ {
 public:
  inline AppendEntryResponse() : AppendEntryResponse(nullptr) {}
  ~AppendEntryResponse() override;
  explicit constexpr AppendEntryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntryResponse(const AppendEntryResponse& from);
  AppendEntryResponse(AppendEntryResponse&& from) noexcept
    : AppendEntryResponse() {
    *this = ::std::move(from);
  }

  inline AppendEntryResponse& operator=(const AppendEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntryResponse& operator=(AppendEntryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntryResponse* internal_default_instance() {
    return reinterpret_cast<const AppendEntryResponse*>(
               &_AppendEntryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AppendEntryResponse& a, AppendEntryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppendEntryResponse* New() const final {
    return new AppendEntryResponse();
  }

  AppendEntryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppendEntryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AppendEntryResponse";
  }
  protected:
  explicit AppendEntryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:AppendEntryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RequestVoteRequest) */ {
 public:
  inline RequestVoteRequest() : RequestVoteRequest(nullptr) {}
  ~RequestVoteRequest() override;
  explicit constexpr RequestVoteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteRequest(const RequestVoteRequest& from);
  RequestVoteRequest(RequestVoteRequest&& from) noexcept
    : RequestVoteRequest() {
    *this = ::std::move(from);
  }

  inline RequestVoteRequest& operator=(const RequestVoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteRequest& operator=(RequestVoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteRequest* internal_default_instance() {
    return reinterpret_cast<const RequestVoteRequest*>(
               &_RequestVoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RequestVoteRequest& a, RequestVoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteRequest* New() const final {
    return new RequestVoteRequest();
  }

  RequestVoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestVoteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RequestVoteRequest";
  }
  protected:
  explicit RequestVoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kCandidateIdFieldNumber = 2,
    kLastLogEntryFieldNumber = 3,
    kLastLogTermFieldNumber = 4,
  };
  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 candidate_id = 2;
  void clear_candidate_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 candidate_id() const;
  void set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_candidate_id() const;
  void _internal_set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 last_log_entry = 3;
  void clear_last_log_entry();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_entry() const;
  void set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_log_entry() const;
  void _internal_set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 last_log_term = 4;
  void clear_last_log_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_term() const;
  void set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_log_term() const;
  void _internal_set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:RequestVoteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  ::PROTOBUF_NAMESPACE_ID::uint64 candidate_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_entry_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_term_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RequestVoteResponse) */ {
 public:
  inline RequestVoteResponse() : RequestVoteResponse(nullptr) {}
  ~RequestVoteResponse() override;
  explicit constexpr RequestVoteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteResponse(const RequestVoteResponse& from);
  RequestVoteResponse(RequestVoteResponse&& from) noexcept
    : RequestVoteResponse() {
    *this = ::std::move(from);
  }

  inline RequestVoteResponse& operator=(const RequestVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteResponse& operator=(RequestVoteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteResponse* internal_default_instance() {
    return reinterpret_cast<const RequestVoteResponse*>(
               &_RequestVoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RequestVoteResponse& a, RequestVoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteResponse* New() const final {
    return new RequestVoteResponse();
  }

  RequestVoteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestVoteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RequestVoteResponse";
  }
  protected:
  explicit RequestVoteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kVoteGrantedFieldNumber = 2,
  };
  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool vote_granted = 2;
  void clear_vote_granted();
  bool vote_granted() const;
  void set_vote_granted(bool value);
  private:
  bool _internal_vote_granted() const;
  void _internal_set_vote_granted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RequestVoteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  bool vote_granted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class WorkerConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerConnectRequest) */ {
 public:
  inline WorkerConnectRequest() : WorkerConnectRequest(nullptr) {}
  ~WorkerConnectRequest() override;
  explicit constexpr WorkerConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerConnectRequest(const WorkerConnectRequest& from);
  WorkerConnectRequest(WorkerConnectRequest&& from) noexcept
    : WorkerConnectRequest() {
    *this = ::std::move(from);
  }

  inline WorkerConnectRequest& operator=(const WorkerConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerConnectRequest& operator=(WorkerConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerConnectRequest* internal_default_instance() {
    return reinterpret_cast<const WorkerConnectRequest*>(
               &_WorkerConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(WorkerConnectRequest& a, WorkerConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerConnectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerConnectRequest* New() const final {
    return new WorkerConnectRequest();
  }

  WorkerConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerConnectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerConnectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerConnectRequest";
  }
  protected:
  explicit WorkerConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskResultFieldNumber = 3,
    kTaskIdFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // .TaskResult task_result = 3;
  bool has_task_result() const;
  private:
  bool _internal_has_task_result() const;
  public:
  void clear_task_result();
  const ::TaskResult& task_result() const;
  PROTOBUF_MUST_USE_RESULT ::TaskResult* release_task_result();
  ::TaskResult* mutable_task_result();
  void set_allocated_task_result(::TaskResult* task_result);
  private:
  const ::TaskResult& _internal_task_result() const;
  ::TaskResult* _internal_mutable_task_result();
  public:
  void unsafe_arena_set_allocated_task_result(
      ::TaskResult* task_result);
  ::TaskResult* unsafe_arena_release_task_result();

  // uint64 task_id = 2;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .WorkerStatus status = 1;
  void clear_status();
  ::WorkerStatus status() const;
  void set_status(::WorkerStatus value);
  private:
  ::WorkerStatus _internal_status() const;
  void _internal_set_status(::WorkerStatus value);
  public:

  // @@protoc_insertion_point(class_scope:WorkerConnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskResult* task_result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class WorkerConnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerConnectResponse) */ {
 public:
  inline WorkerConnectResponse() : WorkerConnectResponse(nullptr) {}
  ~WorkerConnectResponse() override;
  explicit constexpr WorkerConnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerConnectResponse(const WorkerConnectResponse& from);
  WorkerConnectResponse(WorkerConnectResponse&& from) noexcept
    : WorkerConnectResponse() {
    *this = ::std::move(from);
  }

  inline WorkerConnectResponse& operator=(const WorkerConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerConnectResponse& operator=(WorkerConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerConnectResponse* internal_default_instance() {
    return reinterpret_cast<const WorkerConnectResponse*>(
               &_WorkerConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(WorkerConnectResponse& a, WorkerConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerConnectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerConnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerConnectResponse* New() const final {
    return new WorkerConnectResponse();
  }

  WorkerConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerConnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerConnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerConnectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerConnectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerConnectResponse";
  }
  protected:
  explicit WorkerConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskDataFieldNumber = 4,
    kTaskResultFieldNumber = 5,
    kTaskIdFieldNumber = 2,
    kLeaderIdFieldNumber = 3,
    kCommandFieldNumber = 1,
  };
  // .TaskData task_data = 4;
  bool has_task_data() const;
  private:
  bool _internal_has_task_data() const;
  public:
  void clear_task_data();
  const ::TaskData& task_data() const;
  PROTOBUF_MUST_USE_RESULT ::TaskData* release_task_data();
  ::TaskData* mutable_task_data();
  void set_allocated_task_data(::TaskData* task_data);
  private:
  const ::TaskData& _internal_task_data() const;
  ::TaskData* _internal_mutable_task_data();
  public:
  void unsafe_arena_set_allocated_task_data(
      ::TaskData* task_data);
  ::TaskData* unsafe_arena_release_task_data();

  // .TaskResult task_result = 5;
  bool has_task_result() const;
  private:
  bool _internal_has_task_result() const;
  public:
  void clear_task_result();
  const ::TaskResult& task_result() const;
  PROTOBUF_MUST_USE_RESULT ::TaskResult* release_task_result();
  ::TaskResult* mutable_task_result();
  void set_allocated_task_result(::TaskResult* task_result);
  private:
  const ::TaskResult& _internal_task_result() const;
  ::TaskResult* _internal_mutable_task_result();
  public:
  void unsafe_arena_set_allocated_task_result(
      ::TaskResult* task_result);
  ::TaskResult* unsafe_arena_release_task_result();

  // uint64 task_id = 2;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 leader_id = 3;
  void clear_leader_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id() const;
  void set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_id() const;
  void _internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .WorkerCommand command = 1;
  void clear_command();
  ::WorkerCommand command() const;
  void set_command(::WorkerCommand value);
  private:
  ::WorkerCommand _internal_command() const;
  void _internal_set_command(::WorkerCommand value);
  public:

  // @@protoc_insertion_point(class_scope:WorkerConnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskData* task_data_;
  ::TaskResult* task_result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class RaftConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftConfig) */ {
 public:
  inline RaftConfig() : RaftConfig(nullptr) {}
  ~RaftConfig() override;
  explicit constexpr RaftConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftConfig(const RaftConfig& from);
  RaftConfig(RaftConfig&& from) noexcept
    : RaftConfig() {
    *this = ::std::move(from);
  }

  inline RaftConfig& operator=(const RaftConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftConfig& operator=(RaftConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaftConfig* internal_default_instance() {
    return reinterpret_cast<const RaftConfig*>(
               &_RaftConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RaftConfig& a, RaftConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RaftConfig* New() const final {
    return new RaftConfig();
  }

  RaftConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RaftConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RaftConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftConfig";
  }
  protected:
  explicit RaftConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 4,
    kWorkersFieldNumber = 5,
    kUserAddressFieldNumber = 1,
    kRaftAddressFieldNumber = 2,
    kWorkerAddressFieldNumber = 3,
  };
  // repeated string peers = 4;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  const std::string& peers(int index) const;
  std::string* mutable_peers(int index);
  void set_peers(int index, const std::string& value);
  void set_peers(int index, std::string&& value);
  void set_peers(int index, const char* value);
  void set_peers(int index, const char* value, size_t size);
  std::string* add_peers();
  void add_peers(const std::string& value);
  void add_peers(std::string&& value);
  void add_peers(const char* value);
  void add_peers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& peers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_peers();
  private:
  const std::string& _internal_peers(int index) const;
  std::string* _internal_add_peers();
  public:

  // repeated string workers = 5;
  int workers_size() const;
  private:
  int _internal_workers_size() const;
  public:
  void clear_workers();
  const std::string& workers(int index) const;
  std::string* mutable_workers(int index);
  void set_workers(int index, const std::string& value);
  void set_workers(int index, std::string&& value);
  void set_workers(int index, const char* value);
  void set_workers(int index, const char* value, size_t size);
  std::string* add_workers();
  void add_workers(const std::string& value);
  void add_workers(std::string&& value);
  void add_workers(const char* value);
  void add_workers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& workers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_workers();
  private:
  const std::string& _internal_workers(int index) const;
  std::string* _internal_add_workers();
  public:

  // string user_address = 1;
  void clear_user_address();
  const std::string& user_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_address();
  void set_allocated_user_address(std::string* user_address);
  private:
  const std::string& _internal_user_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_address(const std::string& value);
  std::string* _internal_mutable_user_address();
  public:

  // string raft_address = 2;
  void clear_raft_address();
  const std::string& raft_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raft_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raft_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_raft_address();
  void set_allocated_raft_address(std::string* raft_address);
  private:
  const std::string& _internal_raft_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raft_address(const std::string& value);
  std::string* _internal_mutable_raft_address();
  public:

  // string worker_address = 3;
  void clear_worker_address();
  const std::string& worker_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_worker_address();
  void set_allocated_worker_address(std::string* worker_address);
  private:
  const std::string& _internal_worker_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_address(const std::string& value);
  std::string* _internal_mutable_worker_address();
  public:

  // @@protoc_insertion_point(class_scope:RaftConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> peers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> workers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raft_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// TaskData

// repeated int32 data = 1;
inline int TaskData::_internal_data_size() const {
  return data_.size();
}
inline int TaskData::data_size() const {
  return _internal_data_size();
}
inline void TaskData::clear_data() {
  data_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskData::_internal_data(int index) const {
  return data_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskData::data(int index) const {
  // @@protoc_insertion_point(field_get:TaskData.data)
  return _internal_data(index);
}
inline void TaskData::set_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:TaskData.data)
}
inline void TaskData::_internal_add_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  data_.Add(value);
}
inline void TaskData::add_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:TaskData.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TaskData::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TaskData::data() const {
  // @@protoc_insertion_point(field_list:TaskData.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TaskData::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TaskData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:TaskData.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// TaskResult

// int32 result = 1;
inline void TaskResult::clear_result() {
  result_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskResult::_internal_result() const {
  return result_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskResult::result() const {
  // @@protoc_insertion_point(field_get:TaskResult.result)
  return _internal_result();
}
inline void TaskResult::_internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  result_ = value;
}
inline void TaskResult::set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:TaskResult.result)
}

// -------------------------------------------------------------------

// TaskState

// uint64 task_id = 1;
inline void TaskState::clear_task_id() {
  task_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskState::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskState::task_id() const {
  // @@protoc_insertion_point(field_get:TaskState.task_id)
  return _internal_task_id();
}
inline void TaskState::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  task_id_ = value;
}
inline void TaskState::set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:TaskState.task_id)
}

// .TaskResult task_result = 2;
inline bool TaskState::_internal_has_task_result() const {
  return this != internal_default_instance() && task_result_ != nullptr;
}
inline bool TaskState::has_task_result() const {
  return _internal_has_task_result();
}
inline void TaskState::clear_task_result() {
  if (GetArenaForAllocation() == nullptr && task_result_ != nullptr) {
    delete task_result_;
  }
  task_result_ = nullptr;
}
inline const ::TaskResult& TaskState::_internal_task_result() const {
  const ::TaskResult* p = task_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskResult&>(
      ::_TaskResult_default_instance_);
}
inline const ::TaskResult& TaskState::task_result() const {
  // @@protoc_insertion_point(field_get:TaskState.task_result)
  return _internal_task_result();
}
inline void TaskState::unsafe_arena_set_allocated_task_result(
    ::TaskResult* task_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_result_);
  }
  task_result_ = task_result;
  if (task_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TaskState.task_result)
}
inline ::TaskResult* TaskState::release_task_result() {
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskResult* TaskState::unsafe_arena_release_task_result() {
  // @@protoc_insertion_point(field_release:TaskState.task_result)
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
  return temp;
}
inline ::TaskResult* TaskState::_internal_mutable_task_result() {
  
  if (task_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskResult>(GetArenaForAllocation());
    task_result_ = p;
  }
  return task_result_;
}
inline ::TaskResult* TaskState::mutable_task_result() {
  ::TaskResult* _msg = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:TaskState.task_result)
  return _msg;
}
inline void TaskState::set_allocated_task_result(::TaskResult* task_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_result_;
  }
  if (task_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskResult>::GetOwningArena(task_result);
    if (message_arena != submessage_arena) {
      task_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_result, submessage_arena);
    }
    
  } else {
    
  }
  task_result_ = task_result;
  // @@protoc_insertion_point(field_set_allocated:TaskState.task_result)
}

// -------------------------------------------------------------------

// UserConnectRequest

// .UserStatus status = 1;
inline void UserConnectRequest::clear_status() {
  status_ = 0;
}
inline ::UserStatus UserConnectRequest::_internal_status() const {
  return static_cast< ::UserStatus >(status_);
}
inline ::UserStatus UserConnectRequest::status() const {
  // @@protoc_insertion_point(field_get:UserConnectRequest.status)
  return _internal_status();
}
inline void UserConnectRequest::_internal_set_status(::UserStatus value) {
  
  status_ = value;
}
inline void UserConnectRequest::set_status(::UserStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:UserConnectRequest.status)
}

// .TaskData task_data = 2;
inline bool UserConnectRequest::_internal_has_task_data() const {
  return this != internal_default_instance() && task_data_ != nullptr;
}
inline bool UserConnectRequest::has_task_data() const {
  return _internal_has_task_data();
}
inline void UserConnectRequest::clear_task_data() {
  if (GetArenaForAllocation() == nullptr && task_data_ != nullptr) {
    delete task_data_;
  }
  task_data_ = nullptr;
}
inline const ::TaskData& UserConnectRequest::_internal_task_data() const {
  const ::TaskData* p = task_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskData&>(
      ::_TaskData_default_instance_);
}
inline const ::TaskData& UserConnectRequest::task_data() const {
  // @@protoc_insertion_point(field_get:UserConnectRequest.task_data)
  return _internal_task_data();
}
inline void UserConnectRequest::unsafe_arena_set_allocated_task_data(
    ::TaskData* task_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_data_);
  }
  task_data_ = task_data;
  if (task_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserConnectRequest.task_data)
}
inline ::TaskData* UserConnectRequest::release_task_data() {
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskData* UserConnectRequest::unsafe_arena_release_task_data() {
  // @@protoc_insertion_point(field_release:UserConnectRequest.task_data)
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
  return temp;
}
inline ::TaskData* UserConnectRequest::_internal_mutable_task_data() {
  
  if (task_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskData>(GetArenaForAllocation());
    task_data_ = p;
  }
  return task_data_;
}
inline ::TaskData* UserConnectRequest::mutable_task_data() {
  ::TaskData* _msg = _internal_mutable_task_data();
  // @@protoc_insertion_point(field_mutable:UserConnectRequest.task_data)
  return _msg;
}
inline void UserConnectRequest::set_allocated_task_data(::TaskData* task_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_data_;
  }
  if (task_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskData>::GetOwningArena(task_data);
    if (message_arena != submessage_arena) {
      task_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_data, submessage_arena);
    }
    
  } else {
    
  }
  task_data_ = task_data;
  // @@protoc_insertion_point(field_set_allocated:UserConnectRequest.task_data)
}

// -------------------------------------------------------------------

// UserConnectResponse

// .UserCommand command = 1;
inline void UserConnectResponse::clear_command() {
  command_ = 0;
}
inline ::UserCommand UserConnectResponse::_internal_command() const {
  return static_cast< ::UserCommand >(command_);
}
inline ::UserCommand UserConnectResponse::command() const {
  // @@protoc_insertion_point(field_get:UserConnectResponse.command)
  return _internal_command();
}
inline void UserConnectResponse::_internal_set_command(::UserCommand value) {
  
  command_ = value;
}
inline void UserConnectResponse::set_command(::UserCommand value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:UserConnectResponse.command)
}

// uint64 leader_id = 2;
inline void UserConnectResponse::clear_leader_id() {
  leader_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserConnectResponse::_internal_leader_id() const {
  return leader_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserConnectResponse::leader_id() const {
  // @@protoc_insertion_point(field_get:UserConnectResponse.leader_id)
  return _internal_leader_id();
}
inline void UserConnectResponse::_internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_id_ = value;
}
inline void UserConnectResponse::set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_id(value);
  // @@protoc_insertion_point(field_set:UserConnectResponse.leader_id)
}

// uint64 task_id = 3;
inline void UserConnectResponse::clear_task_id() {
  task_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserConnectResponse::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserConnectResponse::task_id() const {
  // @@protoc_insertion_point(field_get:UserConnectResponse.task_id)
  return _internal_task_id();
}
inline void UserConnectResponse::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  task_id_ = value;
}
inline void UserConnectResponse::set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:UserConnectResponse.task_id)
}

// .TaskResult task_result = 4;
inline bool UserConnectResponse::_internal_has_task_result() const {
  return this != internal_default_instance() && task_result_ != nullptr;
}
inline bool UserConnectResponse::has_task_result() const {
  return _internal_has_task_result();
}
inline void UserConnectResponse::clear_task_result() {
  if (GetArenaForAllocation() == nullptr && task_result_ != nullptr) {
    delete task_result_;
  }
  task_result_ = nullptr;
}
inline const ::TaskResult& UserConnectResponse::_internal_task_result() const {
  const ::TaskResult* p = task_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskResult&>(
      ::_TaskResult_default_instance_);
}
inline const ::TaskResult& UserConnectResponse::task_result() const {
  // @@protoc_insertion_point(field_get:UserConnectResponse.task_result)
  return _internal_task_result();
}
inline void UserConnectResponse::unsafe_arena_set_allocated_task_result(
    ::TaskResult* task_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_result_);
  }
  task_result_ = task_result;
  if (task_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserConnectResponse.task_result)
}
inline ::TaskResult* UserConnectResponse::release_task_result() {
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskResult* UserConnectResponse::unsafe_arena_release_task_result() {
  // @@protoc_insertion_point(field_release:UserConnectResponse.task_result)
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
  return temp;
}
inline ::TaskResult* UserConnectResponse::_internal_mutable_task_result() {
  
  if (task_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskResult>(GetArenaForAllocation());
    task_result_ = p;
  }
  return task_result_;
}
inline ::TaskResult* UserConnectResponse::mutable_task_result() {
  ::TaskResult* _msg = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:UserConnectResponse.task_result)
  return _msg;
}
inline void UserConnectResponse::set_allocated_task_result(::TaskResult* task_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_result_;
  }
  if (task_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskResult>::GetOwningArena(task_result);
    if (message_arena != submessage_arena) {
      task_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_result, submessage_arena);
    }
    
  } else {
    
  }
  task_result_ = task_result;
  // @@protoc_insertion_point(field_set_allocated:UserConnectResponse.task_result)
}

// -------------------------------------------------------------------

// Task

// uint64 id = 1;
inline void Task::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Task::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Task::id() const {
  // @@protoc_insertion_point(field_get:Task.id)
  return _internal_id();
}
inline void Task::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Task::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Task.id)
}

// uint64 worker_id = 2;
inline void Task::clear_worker_id() {
  worker_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Task::_internal_worker_id() const {
  return worker_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Task::worker_id() const {
  // @@protoc_insertion_point(field_get:Task.worker_id)
  return _internal_worker_id();
}
inline void Task::_internal_set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  worker_id_ = value;
}
inline void Task::set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_worker_id(value);
  // @@protoc_insertion_point(field_set:Task.worker_id)
}

// .TaskData task_data = 3;
inline bool Task::_internal_has_task_data() const {
  return this != internal_default_instance() && task_data_ != nullptr;
}
inline bool Task::has_task_data() const {
  return _internal_has_task_data();
}
inline void Task::clear_task_data() {
  if (GetArenaForAllocation() == nullptr && task_data_ != nullptr) {
    delete task_data_;
  }
  task_data_ = nullptr;
}
inline const ::TaskData& Task::_internal_task_data() const {
  const ::TaskData* p = task_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskData&>(
      ::_TaskData_default_instance_);
}
inline const ::TaskData& Task::task_data() const {
  // @@protoc_insertion_point(field_get:Task.task_data)
  return _internal_task_data();
}
inline void Task::unsafe_arena_set_allocated_task_data(
    ::TaskData* task_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_data_);
  }
  task_data_ = task_data;
  if (task_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Task.task_data)
}
inline ::TaskData* Task::release_task_data() {
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskData* Task::unsafe_arena_release_task_data() {
  // @@protoc_insertion_point(field_release:Task.task_data)
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
  return temp;
}
inline ::TaskData* Task::_internal_mutable_task_data() {
  
  if (task_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskData>(GetArenaForAllocation());
    task_data_ = p;
  }
  return task_data_;
}
inline ::TaskData* Task::mutable_task_data() {
  ::TaskData* _msg = _internal_mutable_task_data();
  // @@protoc_insertion_point(field_mutable:Task.task_data)
  return _msg;
}
inline void Task::set_allocated_task_data(::TaskData* task_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_data_;
  }
  if (task_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskData>::GetOwningArena(task_data);
    if (message_arena != submessage_arena) {
      task_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_data, submessage_arena);
    }
    
  } else {
    
  }
  task_data_ = task_data;
  // @@protoc_insertion_point(field_set_allocated:Task.task_data)
}

// .TaskResult task_result = 4;
inline bool Task::_internal_has_task_result() const {
  return this != internal_default_instance() && task_result_ != nullptr;
}
inline bool Task::has_task_result() const {
  return _internal_has_task_result();
}
inline void Task::clear_task_result() {
  if (GetArenaForAllocation() == nullptr && task_result_ != nullptr) {
    delete task_result_;
  }
  task_result_ = nullptr;
}
inline const ::TaskResult& Task::_internal_task_result() const {
  const ::TaskResult* p = task_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskResult&>(
      ::_TaskResult_default_instance_);
}
inline const ::TaskResult& Task::task_result() const {
  // @@protoc_insertion_point(field_get:Task.task_result)
  return _internal_task_result();
}
inline void Task::unsafe_arena_set_allocated_task_result(
    ::TaskResult* task_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_result_);
  }
  task_result_ = task_result;
  if (task_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Task.task_result)
}
inline ::TaskResult* Task::release_task_result() {
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskResult* Task::unsafe_arena_release_task_result() {
  // @@protoc_insertion_point(field_release:Task.task_result)
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
  return temp;
}
inline ::TaskResult* Task::_internal_mutable_task_result() {
  
  if (task_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskResult>(GetArenaForAllocation());
    task_result_ = p;
  }
  return task_result_;
}
inline ::TaskResult* Task::mutable_task_result() {
  ::TaskResult* _msg = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:Task.task_result)
  return _msg;
}
inline void Task::set_allocated_task_result(::TaskResult* task_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_result_;
  }
  if (task_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskResult>::GetOwningArena(task_result);
    if (message_arena != submessage_arena) {
      task_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_result, submessage_arena);
    }
    
  } else {
    
  }
  task_result_ = task_result;
  // @@protoc_insertion_point(field_set_allocated:Task.task_result)
}

// -------------------------------------------------------------------

// AddRequest

// .TaskStatus to = 1;
inline void AddRequest::clear_to() {
  to_ = 0;
}
inline ::TaskStatus AddRequest::_internal_to() const {
  return static_cast< ::TaskStatus >(to_);
}
inline ::TaskStatus AddRequest::to() const {
  // @@protoc_insertion_point(field_get:AddRequest.to)
  return _internal_to();
}
inline void AddRequest::_internal_set_to(::TaskStatus value) {
  
  to_ = value;
}
inline void AddRequest::set_to(::TaskStatus value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:AddRequest.to)
}

// -------------------------------------------------------------------

// MoveRequest

// .TaskStatus to = 1;
inline void MoveRequest::clear_to() {
  to_ = 0;
}
inline ::TaskStatus MoveRequest::_internal_to() const {
  return static_cast< ::TaskStatus >(to_);
}
inline ::TaskStatus MoveRequest::to() const {
  // @@protoc_insertion_point(field_get:MoveRequest.to)
  return _internal_to();
}
inline void MoveRequest::_internal_set_to(::TaskStatus value) {
  
  to_ = value;
}
inline void MoveRequest::set_to(::TaskStatus value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:MoveRequest.to)
}

// .TaskStatus from = 2;
inline void MoveRequest::clear_from() {
  from_ = 0;
}
inline ::TaskStatus MoveRequest::_internal_from() const {
  return static_cast< ::TaskStatus >(from_);
}
inline ::TaskStatus MoveRequest::from() const {
  // @@protoc_insertion_point(field_get:MoveRequest.from)
  return _internal_from();
}
inline void MoveRequest::_internal_set_from(::TaskStatus value) {
  
  from_ = value;
}
inline void MoveRequest::set_from(::TaskStatus value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:MoveRequest.from)
}

// -------------------------------------------------------------------

// DeleteRequest

// .TaskStatus from = 1;
inline void DeleteRequest::clear_from() {
  from_ = 0;
}
inline ::TaskStatus DeleteRequest::_internal_from() const {
  return static_cast< ::TaskStatus >(from_);
}
inline ::TaskStatus DeleteRequest::from() const {
  // @@protoc_insertion_point(field_get:DeleteRequest.from)
  return _internal_from();
}
inline void DeleteRequest::_internal_set_from(::TaskStatus value) {
  
  from_ = value;
}
inline void DeleteRequest::set_from(::TaskStatus value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:DeleteRequest.from)
}

// -------------------------------------------------------------------

// Entry

// .RaftCommand command = 1;
inline void Entry::clear_command() {
  command_ = 0;
}
inline ::RaftCommand Entry::_internal_command() const {
  return static_cast< ::RaftCommand >(command_);
}
inline ::RaftCommand Entry::command() const {
  // @@protoc_insertion_point(field_get:Entry.command)
  return _internal_command();
}
inline void Entry::_internal_set_command(::RaftCommand value) {
  
  command_ = value;
}
inline void Entry::set_command(::RaftCommand value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:Entry.command)
}

// uint64 term = 2;
inline void Entry::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Entry::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Entry::term() const {
  // @@protoc_insertion_point(field_get:Entry.term)
  return _internal_term();
}
inline void Entry::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void Entry::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:Entry.term)
}

// .Task task = 3;
inline bool Entry::_internal_has_task() const {
  return this != internal_default_instance() && task_ != nullptr;
}
inline bool Entry::has_task() const {
  return _internal_has_task();
}
inline void Entry::clear_task() {
  if (GetArenaForAllocation() == nullptr && task_ != nullptr) {
    delete task_;
  }
  task_ = nullptr;
}
inline const ::Task& Entry::_internal_task() const {
  const ::Task* p = task_;
  return p != nullptr ? *p : reinterpret_cast<const ::Task&>(
      ::_Task_default_instance_);
}
inline const ::Task& Entry::task() const {
  // @@protoc_insertion_point(field_get:Entry.task)
  return _internal_task();
}
inline void Entry::unsafe_arena_set_allocated_task(
    ::Task* task) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_);
  }
  task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Entry.task)
}
inline ::Task* Entry::release_task() {
  
  ::Task* temp = task_;
  task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Task* Entry::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:Entry.task)
  
  ::Task* temp = task_;
  task_ = nullptr;
  return temp;
}
inline ::Task* Entry::_internal_mutable_task() {
  
  if (task_ == nullptr) {
    auto* p = CreateMaybeMessage<::Task>(GetArenaForAllocation());
    task_ = p;
  }
  return task_;
}
inline ::Task* Entry::mutable_task() {
  ::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:Entry.task)
  return _msg;
}
inline void Entry::set_allocated_task(::Task* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_;
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Task>::GetOwningArena(task);
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:Entry.task)
}

// .AddRequest add_request = 4;
inline bool Entry::_internal_has_add_request() const {
  return this != internal_default_instance() && add_request_ != nullptr;
}
inline bool Entry::has_add_request() const {
  return _internal_has_add_request();
}
inline void Entry::clear_add_request() {
  if (GetArenaForAllocation() == nullptr && add_request_ != nullptr) {
    delete add_request_;
  }
  add_request_ = nullptr;
}
inline const ::AddRequest& Entry::_internal_add_request() const {
  const ::AddRequest* p = add_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::AddRequest&>(
      ::_AddRequest_default_instance_);
}
inline const ::AddRequest& Entry::add_request() const {
  // @@protoc_insertion_point(field_get:Entry.add_request)
  return _internal_add_request();
}
inline void Entry::unsafe_arena_set_allocated_add_request(
    ::AddRequest* add_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(add_request_);
  }
  add_request_ = add_request;
  if (add_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Entry.add_request)
}
inline ::AddRequest* Entry::release_add_request() {
  
  ::AddRequest* temp = add_request_;
  add_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AddRequest* Entry::unsafe_arena_release_add_request() {
  // @@protoc_insertion_point(field_release:Entry.add_request)
  
  ::AddRequest* temp = add_request_;
  add_request_ = nullptr;
  return temp;
}
inline ::AddRequest* Entry::_internal_mutable_add_request() {
  
  if (add_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::AddRequest>(GetArenaForAllocation());
    add_request_ = p;
  }
  return add_request_;
}
inline ::AddRequest* Entry::mutable_add_request() {
  ::AddRequest* _msg = _internal_mutable_add_request();
  // @@protoc_insertion_point(field_mutable:Entry.add_request)
  return _msg;
}
inline void Entry::set_allocated_add_request(::AddRequest* add_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete add_request_;
  }
  if (add_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AddRequest>::GetOwningArena(add_request);
    if (message_arena != submessage_arena) {
      add_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_request, submessage_arena);
    }
    
  } else {
    
  }
  add_request_ = add_request;
  // @@protoc_insertion_point(field_set_allocated:Entry.add_request)
}

// .MoveRequest move_request = 5;
inline bool Entry::_internal_has_move_request() const {
  return this != internal_default_instance() && move_request_ != nullptr;
}
inline bool Entry::has_move_request() const {
  return _internal_has_move_request();
}
inline void Entry::clear_move_request() {
  if (GetArenaForAllocation() == nullptr && move_request_ != nullptr) {
    delete move_request_;
  }
  move_request_ = nullptr;
}
inline const ::MoveRequest& Entry::_internal_move_request() const {
  const ::MoveRequest* p = move_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::MoveRequest&>(
      ::_MoveRequest_default_instance_);
}
inline const ::MoveRequest& Entry::move_request() const {
  // @@protoc_insertion_point(field_get:Entry.move_request)
  return _internal_move_request();
}
inline void Entry::unsafe_arena_set_allocated_move_request(
    ::MoveRequest* move_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(move_request_);
  }
  move_request_ = move_request;
  if (move_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Entry.move_request)
}
inline ::MoveRequest* Entry::release_move_request() {
  
  ::MoveRequest* temp = move_request_;
  move_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MoveRequest* Entry::unsafe_arena_release_move_request() {
  // @@protoc_insertion_point(field_release:Entry.move_request)
  
  ::MoveRequest* temp = move_request_;
  move_request_ = nullptr;
  return temp;
}
inline ::MoveRequest* Entry::_internal_mutable_move_request() {
  
  if (move_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::MoveRequest>(GetArenaForAllocation());
    move_request_ = p;
  }
  return move_request_;
}
inline ::MoveRequest* Entry::mutable_move_request() {
  ::MoveRequest* _msg = _internal_mutable_move_request();
  // @@protoc_insertion_point(field_mutable:Entry.move_request)
  return _msg;
}
inline void Entry::set_allocated_move_request(::MoveRequest* move_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete move_request_;
  }
  if (move_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MoveRequest>::GetOwningArena(move_request);
    if (message_arena != submessage_arena) {
      move_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move_request, submessage_arena);
    }
    
  } else {
    
  }
  move_request_ = move_request;
  // @@protoc_insertion_point(field_set_allocated:Entry.move_request)
}

// .DeleteRequest delete_request = 6;
inline bool Entry::_internal_has_delete_request() const {
  return this != internal_default_instance() && delete_request_ != nullptr;
}
inline bool Entry::has_delete_request() const {
  return _internal_has_delete_request();
}
inline void Entry::clear_delete_request() {
  if (GetArenaForAllocation() == nullptr && delete_request_ != nullptr) {
    delete delete_request_;
  }
  delete_request_ = nullptr;
}
inline const ::DeleteRequest& Entry::_internal_delete_request() const {
  const ::DeleteRequest* p = delete_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::DeleteRequest&>(
      ::_DeleteRequest_default_instance_);
}
inline const ::DeleteRequest& Entry::delete_request() const {
  // @@protoc_insertion_point(field_get:Entry.delete_request)
  return _internal_delete_request();
}
inline void Entry::unsafe_arena_set_allocated_delete_request(
    ::DeleteRequest* delete_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_request_);
  }
  delete_request_ = delete_request;
  if (delete_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Entry.delete_request)
}
inline ::DeleteRequest* Entry::release_delete_request() {
  
  ::DeleteRequest* temp = delete_request_;
  delete_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DeleteRequest* Entry::unsafe_arena_release_delete_request() {
  // @@protoc_insertion_point(field_release:Entry.delete_request)
  
  ::DeleteRequest* temp = delete_request_;
  delete_request_ = nullptr;
  return temp;
}
inline ::DeleteRequest* Entry::_internal_mutable_delete_request() {
  
  if (delete_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::DeleteRequest>(GetArenaForAllocation());
    delete_request_ = p;
  }
  return delete_request_;
}
inline ::DeleteRequest* Entry::mutable_delete_request() {
  ::DeleteRequest* _msg = _internal_mutable_delete_request();
  // @@protoc_insertion_point(field_mutable:Entry.delete_request)
  return _msg;
}
inline void Entry::set_allocated_delete_request(::DeleteRequest* delete_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete delete_request_;
  }
  if (delete_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DeleteRequest>::GetOwningArena(delete_request);
    if (message_arena != submessage_arena) {
      delete_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_request, submessage_arena);
    }
    
  } else {
    
  }
  delete_request_ = delete_request;
  // @@protoc_insertion_point(field_set_allocated:Entry.delete_request)
}

// -------------------------------------------------------------------

// AppendEntryRequest

// uint64 term = 1;
inline void AppendEntryRequest::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::term() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.term)
  return _internal_term();
}
inline void AppendEntryRequest::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void AppendEntryRequest::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.term)
}

// uint64 leader_id = 2;
inline void AppendEntryRequest::clear_leader_id() {
  leader_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_leader_id() const {
  return leader_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::leader_id() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.leader_id)
  return _internal_leader_id();
}
inline void AppendEntryRequest::_internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_id_ = value;
}
inline void AppendEntryRequest::set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_id(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.leader_id)
}

// uint64 prev_log_index = 3;
inline void AppendEntryRequest::clear_prev_log_index() {
  prev_log_index_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_prev_log_index() const {
  return prev_log_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::prev_log_index() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.prev_log_index)
  return _internal_prev_log_index();
}
inline void AppendEntryRequest::_internal_set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  prev_log_index_ = value;
}
inline void AppendEntryRequest::set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_prev_log_index(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.prev_log_index)
}

// uint64 prev_log_term = 4;
inline void AppendEntryRequest::clear_prev_log_term() {
  prev_log_term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_prev_log_term() const {
  return prev_log_term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::prev_log_term() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.prev_log_term)
  return _internal_prev_log_term();
}
inline void AppendEntryRequest::_internal_set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  prev_log_term_ = value;
}
inline void AppendEntryRequest::set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_prev_log_term(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.prev_log_term)
}

// .Entry entry = 5;
inline bool AppendEntryRequest::_internal_has_entry() const {
  return this != internal_default_instance() && entry_ != nullptr;
}
inline bool AppendEntryRequest::has_entry() const {
  return _internal_has_entry();
}
inline void AppendEntryRequest::clear_entry() {
  if (GetArenaForAllocation() == nullptr && entry_ != nullptr) {
    delete entry_;
  }
  entry_ = nullptr;
}
inline const ::Entry& AppendEntryRequest::_internal_entry() const {
  const ::Entry* p = entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::Entry&>(
      ::_Entry_default_instance_);
}
inline const ::Entry& AppendEntryRequest::entry() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.entry)
  return _internal_entry();
}
inline void AppendEntryRequest::unsafe_arena_set_allocated_entry(
    ::Entry* entry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entry_);
  }
  entry_ = entry;
  if (entry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AppendEntryRequest.entry)
}
inline ::Entry* AppendEntryRequest::release_entry() {
  
  ::Entry* temp = entry_;
  entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Entry* AppendEntryRequest::unsafe_arena_release_entry() {
  // @@protoc_insertion_point(field_release:AppendEntryRequest.entry)
  
  ::Entry* temp = entry_;
  entry_ = nullptr;
  return temp;
}
inline ::Entry* AppendEntryRequest::_internal_mutable_entry() {
  
  if (entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::Entry>(GetArenaForAllocation());
    entry_ = p;
  }
  return entry_;
}
inline ::Entry* AppendEntryRequest::mutable_entry() {
  ::Entry* _msg = _internal_mutable_entry();
  // @@protoc_insertion_point(field_mutable:AppendEntryRequest.entry)
  return _msg;
}
inline void AppendEntryRequest::set_allocated_entry(::Entry* entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete entry_;
  }
  if (entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Entry>::GetOwningArena(entry);
    if (message_arena != submessage_arena) {
      entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    
  } else {
    
  }
  entry_ = entry;
  // @@protoc_insertion_point(field_set_allocated:AppendEntryRequest.entry)
}

// uint64 leader_commit = 6;
inline void AppendEntryRequest::clear_leader_commit() {
  leader_commit_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_leader_commit() const {
  return leader_commit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::leader_commit() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.leader_commit)
  return _internal_leader_commit();
}
inline void AppendEntryRequest::_internal_set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_commit_ = value;
}
inline void AppendEntryRequest::set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_commit(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.leader_commit)
}

// -------------------------------------------------------------------

// AppendEntryResponse

// uint64 term = 1;
inline void AppendEntryResponse::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryResponse::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryResponse::term() const {
  // @@protoc_insertion_point(field_get:AppendEntryResponse.term)
  return _internal_term();
}
inline void AppendEntryResponse::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void AppendEntryResponse::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:AppendEntryResponse.term)
}

// bool success = 2;
inline void AppendEntryResponse::clear_success() {
  success_ = false;
}
inline bool AppendEntryResponse::_internal_success() const {
  return success_;
}
inline bool AppendEntryResponse::success() const {
  // @@protoc_insertion_point(field_get:AppendEntryResponse.success)
  return _internal_success();
}
inline void AppendEntryResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void AppendEntryResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:AppendEntryResponse.success)
}

// -------------------------------------------------------------------

// RequestVoteRequest

// uint64 term = 1;
inline void RequestVoteRequest::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::term() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.term)
  return _internal_term();
}
inline void RequestVoteRequest::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void RequestVoteRequest::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.term)
}

// uint64 candidate_id = 2;
inline void RequestVoteRequest::clear_candidate_id() {
  candidate_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_candidate_id() const {
  return candidate_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::candidate_id() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.candidate_id)
  return _internal_candidate_id();
}
inline void RequestVoteRequest::_internal_set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  candidate_id_ = value;
}
inline void RequestVoteRequest::set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_candidate_id(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.candidate_id)
}

// uint64 last_log_entry = 3;
inline void RequestVoteRequest::clear_last_log_entry() {
  last_log_entry_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_last_log_entry() const {
  return last_log_entry_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::last_log_entry() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.last_log_entry)
  return _internal_last_log_entry();
}
inline void RequestVoteRequest::_internal_set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  last_log_entry_ = value;
}
inline void RequestVoteRequest::set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_log_entry(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.last_log_entry)
}

// uint64 last_log_term = 4;
inline void RequestVoteRequest::clear_last_log_term() {
  last_log_term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_last_log_term() const {
  return last_log_term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::last_log_term() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.last_log_term)
  return _internal_last_log_term();
}
inline void RequestVoteRequest::_internal_set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  last_log_term_ = value;
}
inline void RequestVoteRequest::set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_log_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.last_log_term)
}

// -------------------------------------------------------------------

// RequestVoteResponse

// uint64 term = 1;
inline void RequestVoteResponse::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteResponse::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteResponse::term() const {
  // @@protoc_insertion_point(field_get:RequestVoteResponse.term)
  return _internal_term();
}
inline void RequestVoteResponse::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void RequestVoteResponse::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteResponse.term)
}

// bool vote_granted = 2;
inline void RequestVoteResponse::clear_vote_granted() {
  vote_granted_ = false;
}
inline bool RequestVoteResponse::_internal_vote_granted() const {
  return vote_granted_;
}
inline bool RequestVoteResponse::vote_granted() const {
  // @@protoc_insertion_point(field_get:RequestVoteResponse.vote_granted)
  return _internal_vote_granted();
}
inline void RequestVoteResponse::_internal_set_vote_granted(bool value) {
  
  vote_granted_ = value;
}
inline void RequestVoteResponse::set_vote_granted(bool value) {
  _internal_set_vote_granted(value);
  // @@protoc_insertion_point(field_set:RequestVoteResponse.vote_granted)
}

// -------------------------------------------------------------------

// WorkerConnectRequest

// .WorkerStatus status = 1;
inline void WorkerConnectRequest::clear_status() {
  status_ = 0;
}
inline ::WorkerStatus WorkerConnectRequest::_internal_status() const {
  return static_cast< ::WorkerStatus >(status_);
}
inline ::WorkerStatus WorkerConnectRequest::status() const {
  // @@protoc_insertion_point(field_get:WorkerConnectRequest.status)
  return _internal_status();
}
inline void WorkerConnectRequest::_internal_set_status(::WorkerStatus value) {
  
  status_ = value;
}
inline void WorkerConnectRequest::set_status(::WorkerStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:WorkerConnectRequest.status)
}

// uint64 task_id = 2;
inline void WorkerConnectRequest::clear_task_id() {
  task_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectRequest::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectRequest::task_id() const {
  // @@protoc_insertion_point(field_get:WorkerConnectRequest.task_id)
  return _internal_task_id();
}
inline void WorkerConnectRequest::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  task_id_ = value;
}
inline void WorkerConnectRequest::set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:WorkerConnectRequest.task_id)
}

// .TaskResult task_result = 3;
inline bool WorkerConnectRequest::_internal_has_task_result() const {
  return this != internal_default_instance() && task_result_ != nullptr;
}
inline bool WorkerConnectRequest::has_task_result() const {
  return _internal_has_task_result();
}
inline void WorkerConnectRequest::clear_task_result() {
  if (GetArenaForAllocation() == nullptr && task_result_ != nullptr) {
    delete task_result_;
  }
  task_result_ = nullptr;
}
inline const ::TaskResult& WorkerConnectRequest::_internal_task_result() const {
  const ::TaskResult* p = task_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskResult&>(
      ::_TaskResult_default_instance_);
}
inline const ::TaskResult& WorkerConnectRequest::task_result() const {
  // @@protoc_insertion_point(field_get:WorkerConnectRequest.task_result)
  return _internal_task_result();
}
inline void WorkerConnectRequest::unsafe_arena_set_allocated_task_result(
    ::TaskResult* task_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_result_);
  }
  task_result_ = task_result;
  if (task_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerConnectRequest.task_result)
}
inline ::TaskResult* WorkerConnectRequest::release_task_result() {
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskResult* WorkerConnectRequest::unsafe_arena_release_task_result() {
  // @@protoc_insertion_point(field_release:WorkerConnectRequest.task_result)
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
  return temp;
}
inline ::TaskResult* WorkerConnectRequest::_internal_mutable_task_result() {
  
  if (task_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskResult>(GetArenaForAllocation());
    task_result_ = p;
  }
  return task_result_;
}
inline ::TaskResult* WorkerConnectRequest::mutable_task_result() {
  ::TaskResult* _msg = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:WorkerConnectRequest.task_result)
  return _msg;
}
inline void WorkerConnectRequest::set_allocated_task_result(::TaskResult* task_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_result_;
  }
  if (task_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskResult>::GetOwningArena(task_result);
    if (message_arena != submessage_arena) {
      task_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_result, submessage_arena);
    }
    
  } else {
    
  }
  task_result_ = task_result;
  // @@protoc_insertion_point(field_set_allocated:WorkerConnectRequest.task_result)
}

// -------------------------------------------------------------------

// WorkerConnectResponse

// .WorkerCommand command = 1;
inline void WorkerConnectResponse::clear_command() {
  command_ = 0;
}
inline ::WorkerCommand WorkerConnectResponse::_internal_command() const {
  return static_cast< ::WorkerCommand >(command_);
}
inline ::WorkerCommand WorkerConnectResponse::command() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.command)
  return _internal_command();
}
inline void WorkerConnectResponse::_internal_set_command(::WorkerCommand value) {
  
  command_ = value;
}
inline void WorkerConnectResponse::set_command(::WorkerCommand value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:WorkerConnectResponse.command)
}

// uint64 task_id = 2;
inline void WorkerConnectResponse::clear_task_id() {
  task_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectResponse::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectResponse::task_id() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.task_id)
  return _internal_task_id();
}
inline void WorkerConnectResponse::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  task_id_ = value;
}
inline void WorkerConnectResponse::set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:WorkerConnectResponse.task_id)
}

// uint64 leader_id = 3;
inline void WorkerConnectResponse::clear_leader_id() {
  leader_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectResponse::_internal_leader_id() const {
  return leader_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectResponse::leader_id() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.leader_id)
  return _internal_leader_id();
}
inline void WorkerConnectResponse::_internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_id_ = value;
}
inline void WorkerConnectResponse::set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_id(value);
  // @@protoc_insertion_point(field_set:WorkerConnectResponse.leader_id)
}

// .TaskData task_data = 4;
inline bool WorkerConnectResponse::_internal_has_task_data() const {
  return this != internal_default_instance() && task_data_ != nullptr;
}
inline bool WorkerConnectResponse::has_task_data() const {
  return _internal_has_task_data();
}
inline void WorkerConnectResponse::clear_task_data() {
  if (GetArenaForAllocation() == nullptr && task_data_ != nullptr) {
    delete task_data_;
  }
  task_data_ = nullptr;
}
inline const ::TaskData& WorkerConnectResponse::_internal_task_data() const {
  const ::TaskData* p = task_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskData&>(
      ::_TaskData_default_instance_);
}
inline const ::TaskData& WorkerConnectResponse::task_data() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.task_data)
  return _internal_task_data();
}
inline void WorkerConnectResponse::unsafe_arena_set_allocated_task_data(
    ::TaskData* task_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_data_);
  }
  task_data_ = task_data;
  if (task_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerConnectResponse.task_data)
}
inline ::TaskData* WorkerConnectResponse::release_task_data() {
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskData* WorkerConnectResponse::unsafe_arena_release_task_data() {
  // @@protoc_insertion_point(field_release:WorkerConnectResponse.task_data)
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
  return temp;
}
inline ::TaskData* WorkerConnectResponse::_internal_mutable_task_data() {
  
  if (task_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskData>(GetArenaForAllocation());
    task_data_ = p;
  }
  return task_data_;
}
inline ::TaskData* WorkerConnectResponse::mutable_task_data() {
  ::TaskData* _msg = _internal_mutable_task_data();
  // @@protoc_insertion_point(field_mutable:WorkerConnectResponse.task_data)
  return _msg;
}
inline void WorkerConnectResponse::set_allocated_task_data(::TaskData* task_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_data_;
  }
  if (task_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskData>::GetOwningArena(task_data);
    if (message_arena != submessage_arena) {
      task_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_data, submessage_arena);
    }
    
  } else {
    
  }
  task_data_ = task_data;
  // @@protoc_insertion_point(field_set_allocated:WorkerConnectResponse.task_data)
}

// .TaskResult task_result = 5;
inline bool WorkerConnectResponse::_internal_has_task_result() const {
  return this != internal_default_instance() && task_result_ != nullptr;
}
inline bool WorkerConnectResponse::has_task_result() const {
  return _internal_has_task_result();
}
inline void WorkerConnectResponse::clear_task_result() {
  if (GetArenaForAllocation() == nullptr && task_result_ != nullptr) {
    delete task_result_;
  }
  task_result_ = nullptr;
}
inline const ::TaskResult& WorkerConnectResponse::_internal_task_result() const {
  const ::TaskResult* p = task_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskResult&>(
      ::_TaskResult_default_instance_);
}
inline const ::TaskResult& WorkerConnectResponse::task_result() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.task_result)
  return _internal_task_result();
}
inline void WorkerConnectResponse::unsafe_arena_set_allocated_task_result(
    ::TaskResult* task_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_result_);
  }
  task_result_ = task_result;
  if (task_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerConnectResponse.task_result)
}
inline ::TaskResult* WorkerConnectResponse::release_task_result() {
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskResult* WorkerConnectResponse::unsafe_arena_release_task_result() {
  // @@protoc_insertion_point(field_release:WorkerConnectResponse.task_result)
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
  return temp;
}
inline ::TaskResult* WorkerConnectResponse::_internal_mutable_task_result() {
  
  if (task_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskResult>(GetArenaForAllocation());
    task_result_ = p;
  }
  return task_result_;
}
inline ::TaskResult* WorkerConnectResponse::mutable_task_result() {
  ::TaskResult* _msg = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:WorkerConnectResponse.task_result)
  return _msg;
}
inline void WorkerConnectResponse::set_allocated_task_result(::TaskResult* task_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_result_;
  }
  if (task_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskResult>::GetOwningArena(task_result);
    if (message_arena != submessage_arena) {
      task_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_result, submessage_arena);
    }
    
  } else {
    
  }
  task_result_ = task_result;
  // @@protoc_insertion_point(field_set_allocated:WorkerConnectResponse.task_result)
}

// -------------------------------------------------------------------

// RaftConfig

// string user_address = 1;
inline void RaftConfig::clear_user_address() {
  user_address_.ClearToEmpty();
}
inline const std::string& RaftConfig::user_address() const {
  // @@protoc_insertion_point(field_get:RaftConfig.user_address)
  return _internal_user_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RaftConfig::set_user_address(ArgT0&& arg0, ArgT... args) {
 
 user_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RaftConfig.user_address)
}
inline std::string* RaftConfig::mutable_user_address() {
  std::string* _s = _internal_mutable_user_address();
  // @@protoc_insertion_point(field_mutable:RaftConfig.user_address)
  return _s;
}
inline const std::string& RaftConfig::_internal_user_address() const {
  return user_address_.Get();
}
inline void RaftConfig::_internal_set_user_address(const std::string& value) {
  
  user_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RaftConfig::_internal_mutable_user_address() {
  
  return user_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RaftConfig::release_user_address() {
  // @@protoc_insertion_point(field_release:RaftConfig.user_address)
  return user_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RaftConfig::set_allocated_user_address(std::string* user_address) {
  if (user_address != nullptr) {
    
  } else {
    
  }
  user_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RaftConfig.user_address)
}

// string raft_address = 2;
inline void RaftConfig::clear_raft_address() {
  raft_address_.ClearToEmpty();
}
inline const std::string& RaftConfig::raft_address() const {
  // @@protoc_insertion_point(field_get:RaftConfig.raft_address)
  return _internal_raft_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RaftConfig::set_raft_address(ArgT0&& arg0, ArgT... args) {
 
 raft_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RaftConfig.raft_address)
}
inline std::string* RaftConfig::mutable_raft_address() {
  std::string* _s = _internal_mutable_raft_address();
  // @@protoc_insertion_point(field_mutable:RaftConfig.raft_address)
  return _s;
}
inline const std::string& RaftConfig::_internal_raft_address() const {
  return raft_address_.Get();
}
inline void RaftConfig::_internal_set_raft_address(const std::string& value) {
  
  raft_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RaftConfig::_internal_mutable_raft_address() {
  
  return raft_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RaftConfig::release_raft_address() {
  // @@protoc_insertion_point(field_release:RaftConfig.raft_address)
  return raft_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RaftConfig::set_allocated_raft_address(std::string* raft_address) {
  if (raft_address != nullptr) {
    
  } else {
    
  }
  raft_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raft_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RaftConfig.raft_address)
}

// string worker_address = 3;
inline void RaftConfig::clear_worker_address() {
  worker_address_.ClearToEmpty();
}
inline const std::string& RaftConfig::worker_address() const {
  // @@protoc_insertion_point(field_get:RaftConfig.worker_address)
  return _internal_worker_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RaftConfig::set_worker_address(ArgT0&& arg0, ArgT... args) {
 
 worker_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RaftConfig.worker_address)
}
inline std::string* RaftConfig::mutable_worker_address() {
  std::string* _s = _internal_mutable_worker_address();
  // @@protoc_insertion_point(field_mutable:RaftConfig.worker_address)
  return _s;
}
inline const std::string& RaftConfig::_internal_worker_address() const {
  return worker_address_.Get();
}
inline void RaftConfig::_internal_set_worker_address(const std::string& value) {
  
  worker_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RaftConfig::_internal_mutable_worker_address() {
  
  return worker_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RaftConfig::release_worker_address() {
  // @@protoc_insertion_point(field_release:RaftConfig.worker_address)
  return worker_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RaftConfig::set_allocated_worker_address(std::string* worker_address) {
  if (worker_address != nullptr) {
    
  } else {
    
  }
  worker_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), worker_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RaftConfig.worker_address)
}

// repeated string peers = 4;
inline int RaftConfig::_internal_peers_size() const {
  return peers_.size();
}
inline int RaftConfig::peers_size() const {
  return _internal_peers_size();
}
inline void RaftConfig::clear_peers() {
  peers_.Clear();
}
inline std::string* RaftConfig::add_peers() {
  std::string* _s = _internal_add_peers();
  // @@protoc_insertion_point(field_add_mutable:RaftConfig.peers)
  return _s;
}
inline const std::string& RaftConfig::_internal_peers(int index) const {
  return peers_.Get(index);
}
inline const std::string& RaftConfig::peers(int index) const {
  // @@protoc_insertion_point(field_get:RaftConfig.peers)
  return _internal_peers(index);
}
inline std::string* RaftConfig::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:RaftConfig.peers)
  return peers_.Mutable(index);
}
inline void RaftConfig::set_peers(int index, const std::string& value) {
  peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:RaftConfig.peers)
}
inline void RaftConfig::set_peers(int index, std::string&& value) {
  peers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:RaftConfig.peers)
}
inline void RaftConfig::set_peers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RaftConfig.peers)
}
inline void RaftConfig::set_peers(int index, const char* value, size_t size) {
  peers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RaftConfig.peers)
}
inline std::string* RaftConfig::_internal_add_peers() {
  return peers_.Add();
}
inline void RaftConfig::add_peers(const std::string& value) {
  peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RaftConfig.peers)
}
inline void RaftConfig::add_peers(std::string&& value) {
  peers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RaftConfig.peers)
}
inline void RaftConfig::add_peers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RaftConfig.peers)
}
inline void RaftConfig::add_peers(const char* value, size_t size) {
  peers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RaftConfig.peers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RaftConfig::peers() const {
  // @@protoc_insertion_point(field_list:RaftConfig.peers)
  return peers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RaftConfig::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:RaftConfig.peers)
  return &peers_;
}

// repeated string workers = 5;
inline int RaftConfig::_internal_workers_size() const {
  return workers_.size();
}
inline int RaftConfig::workers_size() const {
  return _internal_workers_size();
}
inline void RaftConfig::clear_workers() {
  workers_.Clear();
}
inline std::string* RaftConfig::add_workers() {
  std::string* _s = _internal_add_workers();
  // @@protoc_insertion_point(field_add_mutable:RaftConfig.workers)
  return _s;
}
inline const std::string& RaftConfig::_internal_workers(int index) const {
  return workers_.Get(index);
}
inline const std::string& RaftConfig::workers(int index) const {
  // @@protoc_insertion_point(field_get:RaftConfig.workers)
  return _internal_workers(index);
}
inline std::string* RaftConfig::mutable_workers(int index) {
  // @@protoc_insertion_point(field_mutable:RaftConfig.workers)
  return workers_.Mutable(index);
}
inline void RaftConfig::set_workers(int index, const std::string& value) {
  workers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:RaftConfig.workers)
}
inline void RaftConfig::set_workers(int index, std::string&& value) {
  workers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:RaftConfig.workers)
}
inline void RaftConfig::set_workers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  workers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RaftConfig.workers)
}
inline void RaftConfig::set_workers(int index, const char* value, size_t size) {
  workers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RaftConfig.workers)
}
inline std::string* RaftConfig::_internal_add_workers() {
  return workers_.Add();
}
inline void RaftConfig::add_workers(const std::string& value) {
  workers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RaftConfig.workers)
}
inline void RaftConfig::add_workers(std::string&& value) {
  workers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RaftConfig.workers)
}
inline void RaftConfig::add_workers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  workers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RaftConfig.workers)
}
inline void RaftConfig::add_workers(const char* value, size_t size) {
  workers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RaftConfig.workers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RaftConfig::workers() const {
  // @@protoc_insertion_point(field_list:RaftConfig.workers)
  return workers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RaftConfig::mutable_workers() {
  // @@protoc_insertion_point(field_mutable_list:RaftConfig.workers)
  return &workers_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::UserStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UserStatus>() {
  return ::UserStatus_descriptor();
}
template <> struct is_proto_enum< ::UserCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UserCommand>() {
  return ::UserCommand_descriptor();
}
template <> struct is_proto_enum< ::TaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TaskStatus>() {
  return ::TaskStatus_descriptor();
}
template <> struct is_proto_enum< ::RaftCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RaftCommand>() {
  return ::RaftCommand_descriptor();
}
template <> struct is_proto_enum< ::WorkerStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WorkerStatus>() {
  return ::WorkerStatus_descriptor();
}
template <> struct is_proto_enum< ::WorkerCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WorkerCommand>() {
  return ::WorkerCommand_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_abeille_2eproto
