// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: abeille.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_abeille_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_abeille_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_abeille_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_abeille_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_abeille_2eproto;
class AddRequest;
struct AddRequestDefaultTypeInternal;
extern AddRequestDefaultTypeInternal _AddRequest_default_instance_;
class AppendEntryRequest;
struct AppendEntryRequestDefaultTypeInternal;
extern AppendEntryRequestDefaultTypeInternal _AppendEntryRequest_default_instance_;
class AppendEntryResponse;
struct AppendEntryResponseDefaultTypeInternal;
extern AppendEntryResponseDefaultTypeInternal _AppendEntryResponse_default_instance_;
class AssignTaskRequest;
struct AssignTaskRequestDefaultTypeInternal;
extern AssignTaskRequestDefaultTypeInternal _AssignTaskRequest_default_instance_;
class AssignTaskResponse;
struct AssignTaskResponseDefaultTypeInternal;
extern AssignTaskResponseDefaultTypeInternal _AssignTaskResponse_default_instance_;
class Command;
struct CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Entry;
struct EntryDefaultTypeInternal;
extern EntryDefaultTypeInternal _Entry_default_instance_;
class GetWorkerResultRequest;
struct GetWorkerResultRequestDefaultTypeInternal;
extern GetWorkerResultRequestDefaultTypeInternal _GetWorkerResultRequest_default_instance_;
class GetWorkerResultResponse;
struct GetWorkerResultResponseDefaultTypeInternal;
extern GetWorkerResultResponseDefaultTypeInternal _GetWorkerResultResponse_default_instance_;
class MoveRequest;
struct MoveRequestDefaultTypeInternal;
extern MoveRequestDefaultTypeInternal _MoveRequest_default_instance_;
class RequestVoteRequest;
struct RequestVoteRequestDefaultTypeInternal;
extern RequestVoteRequestDefaultTypeInternal _RequestVoteRequest_default_instance_;
class RequestVoteResponse;
struct RequestVoteResponseDefaultTypeInternal;
extern RequestVoteResponseDefaultTypeInternal _RequestVoteResponse_default_instance_;
class SendTaskRequest;
struct SendTaskRequestDefaultTypeInternal;
extern SendTaskRequestDefaultTypeInternal _SendTaskRequest_default_instance_;
class SendTaskResponse;
struct SendTaskResponseDefaultTypeInternal;
extern SendTaskResponseDefaultTypeInternal _SendTaskResponse_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskData;
struct TaskDataDefaultTypeInternal;
extern TaskDataDefaultTypeInternal _TaskData_default_instance_;
class TaskResult;
struct TaskResultDefaultTypeInternal;
extern TaskResultDefaultTypeInternal _TaskResult_default_instance_;
class UploadDataRequest;
struct UploadDataRequestDefaultTypeInternal;
extern UploadDataRequestDefaultTypeInternal _UploadDataRequest_default_instance_;
class UploadDataResponse;
struct UploadDataResponseDefaultTypeInternal;
extern UploadDataResponseDefaultTypeInternal _UploadDataResponse_default_instance_;
class UserConnectRequest;
struct UserConnectRequestDefaultTypeInternal;
extern UserConnectRequestDefaultTypeInternal _UserConnectRequest_default_instance_;
class UserConnectResponse;
struct UserConnectResponseDefaultTypeInternal;
extern UserConnectResponseDefaultTypeInternal _UserConnectResponse_default_instance_;
class WorkerConnectRequest;
struct WorkerConnectRequestDefaultTypeInternal;
extern WorkerConnectRequestDefaultTypeInternal _WorkerConnectRequest_default_instance_;
class WorkerConnectResponse;
struct WorkerConnectResponseDefaultTypeInternal;
extern WorkerConnectResponseDefaultTypeInternal _WorkerConnectResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AddRequest* Arena::CreateMaybeMessage<::AddRequest>(Arena*);
template<> ::AppendEntryRequest* Arena::CreateMaybeMessage<::AppendEntryRequest>(Arena*);
template<> ::AppendEntryResponse* Arena::CreateMaybeMessage<::AppendEntryResponse>(Arena*);
template<> ::AssignTaskRequest* Arena::CreateMaybeMessage<::AssignTaskRequest>(Arena*);
template<> ::AssignTaskResponse* Arena::CreateMaybeMessage<::AssignTaskResponse>(Arena*);
template<> ::Command* Arena::CreateMaybeMessage<::Command>(Arena*);
template<> ::DeleteRequest* Arena::CreateMaybeMessage<::DeleteRequest>(Arena*);
template<> ::Empty* Arena::CreateMaybeMessage<::Empty>(Arena*);
template<> ::Entry* Arena::CreateMaybeMessage<::Entry>(Arena*);
template<> ::GetWorkerResultRequest* Arena::CreateMaybeMessage<::GetWorkerResultRequest>(Arena*);
template<> ::GetWorkerResultResponse* Arena::CreateMaybeMessage<::GetWorkerResultResponse>(Arena*);
template<> ::MoveRequest* Arena::CreateMaybeMessage<::MoveRequest>(Arena*);
template<> ::RequestVoteRequest* Arena::CreateMaybeMessage<::RequestVoteRequest>(Arena*);
template<> ::RequestVoteResponse* Arena::CreateMaybeMessage<::RequestVoteResponse>(Arena*);
template<> ::SendTaskRequest* Arena::CreateMaybeMessage<::SendTaskRequest>(Arena*);
template<> ::SendTaskResponse* Arena::CreateMaybeMessage<::SendTaskResponse>(Arena*);
template<> ::Task* Arena::CreateMaybeMessage<::Task>(Arena*);
template<> ::TaskData* Arena::CreateMaybeMessage<::TaskData>(Arena*);
template<> ::TaskResult* Arena::CreateMaybeMessage<::TaskResult>(Arena*);
template<> ::UploadDataRequest* Arena::CreateMaybeMessage<::UploadDataRequest>(Arena*);
template<> ::UploadDataResponse* Arena::CreateMaybeMessage<::UploadDataResponse>(Arena*);
template<> ::UserConnectRequest* Arena::CreateMaybeMessage<::UserConnectRequest>(Arena*);
template<> ::UserConnectResponse* Arena::CreateMaybeMessage<::UserConnectResponse>(Arena*);
template<> ::WorkerConnectRequest* Arena::CreateMaybeMessage<::WorkerConnectRequest>(Arena*);
template<> ::WorkerConnectResponse* Arena::CreateMaybeMessage<::WorkerConnectResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Command_CommandType : int {
  Command_CommandType_ADD = 0,
  Command_CommandType_MOVE = 1,
  Command_CommandType_DELETE = 2,
  Command_CommandType_Command_CommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Command_CommandType_Command_CommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Command_CommandType_IsValid(int value);
constexpr Command_CommandType Command_CommandType_CommandType_MIN = Command_CommandType_ADD;
constexpr Command_CommandType Command_CommandType_CommandType_MAX = Command_CommandType_DELETE;
constexpr int Command_CommandType_CommandType_ARRAYSIZE = Command_CommandType_CommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Command_CommandType_descriptor();
template<typename T>
inline const std::string& Command_CommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Command_CommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Command_CommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Command_CommandType_descriptor(), enum_t_value);
}
inline bool Command_CommandType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Command_CommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Command_CommandType>(
    Command_CommandType_descriptor(), name, value);
}
enum UserStatus : int {
  USER_STATUS_NONE = 0,
  USER_STATUS_UPLOAD_DATA = 1,
  UserStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserStatus_IsValid(int value);
constexpr UserStatus UserStatus_MIN = USER_STATUS_NONE;
constexpr UserStatus UserStatus_MAX = USER_STATUS_UPLOAD_DATA;
constexpr int UserStatus_ARRAYSIZE = UserStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserStatus_descriptor();
template<typename T>
inline const std::string& UserStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserStatus_descriptor(), enum_t_value);
}
inline bool UserStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserStatus>(
    UserStatus_descriptor(), name, value);
}
enum UserCommand : int {
  USER_COMMAND_NONE = 0,
  USER_COMMAND_REDIRECT = 1,
  USER_COMMAND_RECIEVE_RESULT = 2,
  UserCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserCommand_IsValid(int value);
constexpr UserCommand UserCommand_MIN = USER_COMMAND_NONE;
constexpr UserCommand UserCommand_MAX = USER_COMMAND_RECIEVE_RESULT;
constexpr int UserCommand_ARRAYSIZE = UserCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserCommand_descriptor();
template<typename T>
inline const std::string& UserCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserCommand_descriptor(), enum_t_value);
}
inline bool UserCommand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserCommand>(
    UserCommand_descriptor(), name, value);
}
enum TaskStatus : int {
  TO_DO = 0,
  IN_PROGRESS = 2,
  DONE = 1,
  TaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskStatus_IsValid(int value);
constexpr TaskStatus TaskStatus_MIN = TO_DO;
constexpr TaskStatus TaskStatus_MAX = IN_PROGRESS;
constexpr int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskStatus_descriptor();
template<typename T>
inline const std::string& TaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskStatus_descriptor(), enum_t_value);
}
inline bool TaskStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskStatus>(
    TaskStatus_descriptor(), name, value);
}
enum WorkerStatus : int {
  WORKER_STATUS_IDLE = 0,
  WORKER_STATUS_BUSY = 2,
  WORKER_STATUS_COMPLETED = 3,
  WorkerStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkerStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkerStatus_IsValid(int value);
constexpr WorkerStatus WorkerStatus_MIN = WORKER_STATUS_IDLE;
constexpr WorkerStatus WorkerStatus_MAX = WORKER_STATUS_COMPLETED;
constexpr int WorkerStatus_ARRAYSIZE = WorkerStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkerStatus_descriptor();
template<typename T>
inline const std::string& WorkerStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkerStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkerStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkerStatus_descriptor(), enum_t_value);
}
inline bool WorkerStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkerStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkerStatus>(
    WorkerStatus_descriptor(), name, value);
}
enum WorkerCommand : int {
  WORKER_COMMAND_NONE = 0,
  WORKER_COMMAND_ASSIGN = 1,
  WORKER_COMMAND_PROCESS = 2,
  WORKER_COMMAND_REDIRECT = 3,
  WorkerCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkerCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkerCommand_IsValid(int value);
constexpr WorkerCommand WorkerCommand_MIN = WORKER_COMMAND_NONE;
constexpr WorkerCommand WorkerCommand_MAX = WORKER_COMMAND_REDIRECT;
constexpr int WorkerCommand_ARRAYSIZE = WorkerCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkerCommand_descriptor();
template<typename T>
inline const std::string& WorkerCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkerCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkerCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkerCommand_descriptor(), enum_t_value);
}
inline bool WorkerCommand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkerCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkerCommand>(
    WorkerCommand_descriptor(), name, value);
}
// ===================================================================

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  ~Empty() override;
  explicit constexpr Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return new Empty();
  }

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Empty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Empty& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class TaskData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskData) */ {
 public:
  inline TaskData() : TaskData(nullptr) {}
  ~TaskData() override;
  explicit constexpr TaskData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskData(const TaskData& from);
  TaskData(TaskData&& from) noexcept
    : TaskData() {
    *this = ::std::move(from);
  }

  inline TaskData& operator=(const TaskData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskData& operator=(TaskData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskData* internal_default_instance() {
    return reinterpret_cast<const TaskData*>(
               &_TaskData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TaskData& a, TaskData& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskData* New() const final {
    return new TaskData();
  }

  TaskData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskData";
  }
  protected:
  explicit TaskData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated int32 data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_data() const;
  void _internal_add_data(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_data();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 data(int index) const;
  void set_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_data(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:TaskData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class TaskResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskResult) */ {
 public:
  inline TaskResult() : TaskResult(nullptr) {}
  ~TaskResult() override;
  explicit constexpr TaskResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskResult(const TaskResult& from);
  TaskResult(TaskResult&& from) noexcept
    : TaskResult() {
    *this = ::std::move(from);
  }

  inline TaskResult& operator=(const TaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskResult& operator=(TaskResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskResult* internal_default_instance() {
    return reinterpret_cast<const TaskResult*>(
               &_TaskResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TaskResult& a, TaskResult& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskResult* New() const final {
    return new TaskResult();
  }

  TaskResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskResult";
  }
  protected:
  explicit TaskResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // int32 result = 1;
  void clear_result();
  ::PROTOBUF_NAMESPACE_ID::int32 result() const;
  void set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_result() const;
  void _internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:TaskResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class UserConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserConnectRequest) */ {
 public:
  inline UserConnectRequest() : UserConnectRequest(nullptr) {}
  ~UserConnectRequest() override;
  explicit constexpr UserConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserConnectRequest(const UserConnectRequest& from);
  UserConnectRequest(UserConnectRequest&& from) noexcept
    : UserConnectRequest() {
    *this = ::std::move(from);
  }

  inline UserConnectRequest& operator=(const UserConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserConnectRequest& operator=(UserConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserConnectRequest* internal_default_instance() {
    return reinterpret_cast<const UserConnectRequest*>(
               &_UserConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserConnectRequest& a, UserConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserConnectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserConnectRequest* New() const final {
    return new UserConnectRequest();
  }

  UserConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserConnectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserConnectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserConnectRequest";
  }
  protected:
  explicit UserConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskDataFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // .TaskData task_data = 2;
  bool has_task_data() const;
  private:
  bool _internal_has_task_data() const;
  public:
  void clear_task_data();
  const ::TaskData& task_data() const;
  PROTOBUF_MUST_USE_RESULT ::TaskData* release_task_data();
  ::TaskData* mutable_task_data();
  void set_allocated_task_data(::TaskData* task_data);
  private:
  const ::TaskData& _internal_task_data() const;
  ::TaskData* _internal_mutable_task_data();
  public:
  void unsafe_arena_set_allocated_task_data(
      ::TaskData* task_data);
  ::TaskData* unsafe_arena_release_task_data();

  // .UserStatus status = 1;
  void clear_status();
  ::UserStatus status() const;
  void set_status(::UserStatus value);
  private:
  ::UserStatus _internal_status() const;
  void _internal_set_status(::UserStatus value);
  public:

  // @@protoc_insertion_point(class_scope:UserConnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskData* task_data_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class UploadDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UploadDataRequest) */ {
 public:
  inline UploadDataRequest() : UploadDataRequest(nullptr) {}
  ~UploadDataRequest() override;
  explicit constexpr UploadDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadDataRequest(const UploadDataRequest& from);
  UploadDataRequest(UploadDataRequest&& from) noexcept
    : UploadDataRequest() {
    *this = ::std::move(from);
  }

  inline UploadDataRequest& operator=(const UploadDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadDataRequest& operator=(UploadDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadDataRequest* internal_default_instance() {
    return reinterpret_cast<const UploadDataRequest*>(
               &_UploadDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UploadDataRequest& a, UploadDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadDataRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UploadDataRequest* New() const final {
    return new UploadDataRequest();
  }

  UploadDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UploadDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UploadDataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UploadDataRequest";
  }
  protected:
  explicit UploadDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskDataFieldNumber = 1,
  };
  // .TaskData task_data = 1;
  bool has_task_data() const;
  private:
  bool _internal_has_task_data() const;
  public:
  void clear_task_data();
  const ::TaskData& task_data() const;
  PROTOBUF_MUST_USE_RESULT ::TaskData* release_task_data();
  ::TaskData* mutable_task_data();
  void set_allocated_task_data(::TaskData* task_data);
  private:
  const ::TaskData& _internal_task_data() const;
  ::TaskData* _internal_mutable_task_data();
  public:
  void unsafe_arena_set_allocated_task_data(
      ::TaskData* task_data);
  ::TaskData* unsafe_arena_release_task_data();

  // @@protoc_insertion_point(class_scope:UploadDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskData* task_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class UploadDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UploadDataResponse) */ {
 public:
  inline UploadDataResponse() : UploadDataResponse(nullptr) {}
  ~UploadDataResponse() override;
  explicit constexpr UploadDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadDataResponse(const UploadDataResponse& from);
  UploadDataResponse(UploadDataResponse&& from) noexcept
    : UploadDataResponse() {
    *this = ::std::move(from);
  }

  inline UploadDataResponse& operator=(const UploadDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadDataResponse& operator=(UploadDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadDataResponse* internal_default_instance() {
    return reinterpret_cast<const UploadDataResponse*>(
               &_UploadDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UploadDataResponse& a, UploadDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadDataResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UploadDataResponse* New() const final {
    return new UploadDataResponse();
  }

  UploadDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UploadDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UploadDataResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadDataResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UploadDataResponse";
  }
  protected:
  explicit UploadDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // uint64 task_id = 2;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:UploadDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class UserConnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserConnectResponse) */ {
 public:
  inline UserConnectResponse() : UserConnectResponse(nullptr) {}
  ~UserConnectResponse() override;
  explicit constexpr UserConnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserConnectResponse(const UserConnectResponse& from);
  UserConnectResponse(UserConnectResponse&& from) noexcept
    : UserConnectResponse() {
    *this = ::std::move(from);
  }

  inline UserConnectResponse& operator=(const UserConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserConnectResponse& operator=(UserConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserConnectResponse* internal_default_instance() {
    return reinterpret_cast<const UserConnectResponse*>(
               &_UserConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UserConnectResponse& a, UserConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserConnectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserConnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserConnectResponse* New() const final {
    return new UserConnectResponse();
  }

  UserConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserConnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserConnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserConnectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserConnectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserConnectResponse";
  }
  protected:
  explicit UserConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskResultFieldNumber = 3,
    kUploadDataResponseFieldNumber = 4,
    kLeaderIdFieldNumber = 2,
    kCommandFieldNumber = 1,
  };
  // .TaskResult task_result = 3;
  bool has_task_result() const;
  private:
  bool _internal_has_task_result() const;
  public:
  void clear_task_result();
  const ::TaskResult& task_result() const;
  PROTOBUF_MUST_USE_RESULT ::TaskResult* release_task_result();
  ::TaskResult* mutable_task_result();
  void set_allocated_task_result(::TaskResult* task_result);
  private:
  const ::TaskResult& _internal_task_result() const;
  ::TaskResult* _internal_mutable_task_result();
  public:
  void unsafe_arena_set_allocated_task_result(
      ::TaskResult* task_result);
  ::TaskResult* unsafe_arena_release_task_result();

  // .UploadDataResponse upload_data_response = 4;
  bool has_upload_data_response() const;
  private:
  bool _internal_has_upload_data_response() const;
  public:
  void clear_upload_data_response();
  const ::UploadDataResponse& upload_data_response() const;
  PROTOBUF_MUST_USE_RESULT ::UploadDataResponse* release_upload_data_response();
  ::UploadDataResponse* mutable_upload_data_response();
  void set_allocated_upload_data_response(::UploadDataResponse* upload_data_response);
  private:
  const ::UploadDataResponse& _internal_upload_data_response() const;
  ::UploadDataResponse* _internal_mutable_upload_data_response();
  public:
  void unsafe_arena_set_allocated_upload_data_response(
      ::UploadDataResponse* upload_data_response);
  ::UploadDataResponse* unsafe_arena_release_upload_data_response();

  // uint64 leader_id = 2;
  void clear_leader_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id() const;
  void set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_id() const;
  void _internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .UserCommand command = 1;
  void clear_command();
  ::UserCommand command() const;
  void set_command(::UserCommand value);
  private:
  ::UserCommand _internal_command() const;
  void _internal_set_command(::UserCommand value);
  public:

  // @@protoc_insertion_point(class_scope:UserConnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskResult* task_result_;
  ::UploadDataResponse* upload_data_response_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class Task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  explicit constexpr Task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Task* New() const final {
    return new Task();
  }

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Task& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskDataFieldNumber = 3,
    kTaskResultFieldNumber = 4,
    kIdFieldNumber = 1,
    kAssigneeFieldNumber = 2,
  };
  // .TaskData task_data = 3;
  bool has_task_data() const;
  private:
  bool _internal_has_task_data() const;
  public:
  void clear_task_data();
  const ::TaskData& task_data() const;
  PROTOBUF_MUST_USE_RESULT ::TaskData* release_task_data();
  ::TaskData* mutable_task_data();
  void set_allocated_task_data(::TaskData* task_data);
  private:
  const ::TaskData& _internal_task_data() const;
  ::TaskData* _internal_mutable_task_data();
  public:
  void unsafe_arena_set_allocated_task_data(
      ::TaskData* task_data);
  ::TaskData* unsafe_arena_release_task_data();

  // .TaskResult task_result = 4;
  bool has_task_result() const;
  private:
  bool _internal_has_task_result() const;
  public:
  void clear_task_result();
  const ::TaskResult& task_result() const;
  PROTOBUF_MUST_USE_RESULT ::TaskResult* release_task_result();
  ::TaskResult* mutable_task_result();
  void set_allocated_task_result(::TaskResult* task_result);
  private:
  const ::TaskResult& _internal_task_result() const;
  ::TaskResult* _internal_mutable_task_result();
  public:
  void unsafe_arena_set_allocated_task_result(
      ::TaskResult* task_result);
  ::TaskResult* unsafe_arena_release_task_result();

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 assignee = 2;
  void clear_assignee();
  ::PROTOBUF_NAMESPACE_ID::uint64 assignee() const;
  void set_assignee(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_assignee() const;
  void _internal_set_assignee(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskData* task_data_;
  ::TaskResult* task_result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 assignee_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class AddRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AddRequest) */ {
 public:
  inline AddRequest() : AddRequest(nullptr) {}
  ~AddRequest() override;
  explicit constexpr AddRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddRequest(const AddRequest& from);
  AddRequest(AddRequest&& from) noexcept
    : AddRequest() {
    *this = ::std::move(from);
  }

  inline AddRequest& operator=(const AddRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddRequest& operator=(AddRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddRequest* internal_default_instance() {
    return reinterpret_cast<const AddRequest*>(
               &_AddRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AddRequest& a, AddRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddRequest* New() const final {
    return new AddRequest();
  }

  AddRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AddRequest";
  }
  protected:
  explicit AddRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
  };
  // .TaskStatus to = 1;
  void clear_to();
  ::TaskStatus to() const;
  void set_to(::TaskStatus value);
  private:
  ::TaskStatus _internal_to() const;
  void _internal_set_to(::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:AddRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int to_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class MoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MoveRequest) */ {
 public:
  inline MoveRequest() : MoveRequest(nullptr) {}
  ~MoveRequest() override;
  explicit constexpr MoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveRequest(const MoveRequest& from);
  MoveRequest(MoveRequest&& from) noexcept
    : MoveRequest() {
    *this = ::std::move(from);
  }

  inline MoveRequest& operator=(const MoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveRequest& operator=(MoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveRequest* internal_default_instance() {
    return reinterpret_cast<const MoveRequest*>(
               &_MoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MoveRequest& a, MoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveRequest* New() const final {
    return new MoveRequest();
  }

  MoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MoveRequest";
  }
  protected:
  explicit MoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
    kFromFieldNumber = 2,
  };
  // .TaskStatus to = 1;
  void clear_to();
  ::TaskStatus to() const;
  void set_to(::TaskStatus value);
  private:
  ::TaskStatus _internal_to() const;
  void _internal_set_to(::TaskStatus value);
  public:

  // .TaskStatus from = 2;
  void clear_from();
  ::TaskStatus from() const;
  void set_from(::TaskStatus value);
  private:
  ::TaskStatus _internal_from() const;
  void _internal_set_from(::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:MoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int to_;
  int from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit constexpr DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return new DeleteRequest();
  }

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
  };
  // .TaskStatus from = 1;
  void clear_from();
  ::TaskStatus from() const;
  void set_from(::TaskStatus value);
  private:
  ::TaskStatus _internal_from() const;
  void _internal_set_from(::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class Command final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Command) */ {
 public:
  inline Command() : Command(nullptr) {}
  ~Command() override;
  explicit constexpr Command(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Command& default_instance() {
    return *internal_default_instance();
  }
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return new Command();
  }

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Command& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Command& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Command";
  }
  protected:
  explicit Command(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Command_CommandType CommandType;
  static constexpr CommandType ADD =
    Command_CommandType_ADD;
  static constexpr CommandType MOVE =
    Command_CommandType_MOVE;
  static constexpr CommandType DELETE =
    Command_CommandType_DELETE;
  static inline bool CommandType_IsValid(int value) {
    return Command_CommandType_IsValid(value);
  }
  static constexpr CommandType CommandType_MIN =
    Command_CommandType_CommandType_MIN;
  static constexpr CommandType CommandType_MAX =
    Command_CommandType_CommandType_MAX;
  static constexpr int CommandType_ARRAYSIZE =
    Command_CommandType_CommandType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CommandType_descriptor() {
    return Command_CommandType_descriptor();
  }
  template<typename T>
  static inline const std::string& CommandType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CommandType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CommandType_Name.");
    return Command_CommandType_Name(enum_t_value);
  }
  static inline bool CommandType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CommandType* value) {
    return Command_CommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAddRequestFieldNumber = 2,
    kMoveRequestFieldNumber = 3,
    kDeleteRequestFieldNumber = 4,
    kCommandFieldNumber = 1,
  };
  // .AddRequest add_request = 2;
  bool has_add_request() const;
  private:
  bool _internal_has_add_request() const;
  public:
  void clear_add_request();
  const ::AddRequest& add_request() const;
  PROTOBUF_MUST_USE_RESULT ::AddRequest* release_add_request();
  ::AddRequest* mutable_add_request();
  void set_allocated_add_request(::AddRequest* add_request);
  private:
  const ::AddRequest& _internal_add_request() const;
  ::AddRequest* _internal_mutable_add_request();
  public:
  void unsafe_arena_set_allocated_add_request(
      ::AddRequest* add_request);
  ::AddRequest* unsafe_arena_release_add_request();

  // .MoveRequest move_request = 3;
  bool has_move_request() const;
  private:
  bool _internal_has_move_request() const;
  public:
  void clear_move_request();
  const ::MoveRequest& move_request() const;
  PROTOBUF_MUST_USE_RESULT ::MoveRequest* release_move_request();
  ::MoveRequest* mutable_move_request();
  void set_allocated_move_request(::MoveRequest* move_request);
  private:
  const ::MoveRequest& _internal_move_request() const;
  ::MoveRequest* _internal_mutable_move_request();
  public:
  void unsafe_arena_set_allocated_move_request(
      ::MoveRequest* move_request);
  ::MoveRequest* unsafe_arena_release_move_request();

  // .DeleteRequest delete_request = 4;
  bool has_delete_request() const;
  private:
  bool _internal_has_delete_request() const;
  public:
  void clear_delete_request();
  const ::DeleteRequest& delete_request() const;
  PROTOBUF_MUST_USE_RESULT ::DeleteRequest* release_delete_request();
  ::DeleteRequest* mutable_delete_request();
  void set_allocated_delete_request(::DeleteRequest* delete_request);
  private:
  const ::DeleteRequest& _internal_delete_request() const;
  ::DeleteRequest* _internal_mutable_delete_request();
  public:
  void unsafe_arena_set_allocated_delete_request(
      ::DeleteRequest* delete_request);
  ::DeleteRequest* unsafe_arena_release_delete_request();

  // .Command.CommandType command = 1;
  void clear_command();
  ::Command_CommandType command() const;
  void set_command(::Command_CommandType value);
  private:
  ::Command_CommandType _internal_command() const;
  void _internal_set_command(::Command_CommandType value);
  public:

  // @@protoc_insertion_point(class_scope:Command)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::AddRequest* add_request_;
  ::MoveRequest* move_request_;
  ::DeleteRequest* delete_request_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Entry) */ {
 public:
  inline Entry() : Entry(nullptr) {}
  ~Entry() override;
  explicit constexpr Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entry(const Entry& from);
  Entry(Entry&& from) noexcept
    : Entry() {
    *this = ::std::move(from);
  }

  inline Entry& operator=(const Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entry& operator=(Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entry* internal_default_instance() {
    return reinterpret_cast<const Entry*>(
               &_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Entry& a, Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(Entry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Entry* New() const final {
    return new Entry();
  }

  Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Entry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Entry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Entry";
  }
  protected:
  explicit Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 2,
    kCommandFieldNumber = 3,
    kTermFieldNumber = 1,
  };
  // .Task task = 2;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::Task& task() const;
  PROTOBUF_MUST_USE_RESULT ::Task* release_task();
  ::Task* mutable_task();
  void set_allocated_task(::Task* task);
  private:
  const ::Task& _internal_task() const;
  ::Task* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::Task* task);
  ::Task* unsafe_arena_release_task();

  // .Command command = 3;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::Command& command() const;
  PROTOBUF_MUST_USE_RESULT ::Command* release_command();
  ::Command* mutable_command();
  void set_allocated_command(::Command* command);
  private:
  const ::Command& _internal_command() const;
  ::Command* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::Command* command);
  ::Command* unsafe_arena_release_command();

  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Task* task_;
  ::Command* command_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class AppendEntryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AppendEntryRequest) */ {
 public:
  inline AppendEntryRequest() : AppendEntryRequest(nullptr) {}
  ~AppendEntryRequest() override;
  explicit constexpr AppendEntryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntryRequest(const AppendEntryRequest& from);
  AppendEntryRequest(AppendEntryRequest&& from) noexcept
    : AppendEntryRequest() {
    *this = ::std::move(from);
  }

  inline AppendEntryRequest& operator=(const AppendEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntryRequest& operator=(AppendEntryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntryRequest* internal_default_instance() {
    return reinterpret_cast<const AppendEntryRequest*>(
               &_AppendEntryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AppendEntryRequest& a, AppendEntryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppendEntryRequest* New() const final {
    return new AppendEntryRequest();
  }

  AppendEntryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppendEntryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AppendEntryRequest";
  }
  protected:
  explicit AppendEntryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 5,
    kTermFieldNumber = 1,
    kLeaderIdFieldNumber = 2,
    kPrevLogIndexFieldNumber = 3,
    kPrevLogTermFieldNumber = 4,
    kLeaderCommitFieldNumber = 6,
  };
  // .Entry entry = 5;
  bool has_entry() const;
  private:
  bool _internal_has_entry() const;
  public:
  void clear_entry();
  const ::Entry& entry() const;
  PROTOBUF_MUST_USE_RESULT ::Entry* release_entry();
  ::Entry* mutable_entry();
  void set_allocated_entry(::Entry* entry);
  private:
  const ::Entry& _internal_entry() const;
  ::Entry* _internal_mutable_entry();
  public:
  void unsafe_arena_set_allocated_entry(
      ::Entry* entry);
  ::Entry* unsafe_arena_release_entry();

  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 leader_id = 2;
  void clear_leader_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id() const;
  void set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_id() const;
  void _internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 prev_log_index = 3;
  void clear_prev_log_index();
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_index() const;
  void set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_prev_log_index() const;
  void _internal_set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 prev_log_term = 4;
  void clear_prev_log_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_term() const;
  void set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_prev_log_term() const;
  void _internal_set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 leader_commit = 6;
  void clear_leader_commit();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_commit() const;
  void set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_commit() const;
  void _internal_set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:AppendEntryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Entry* entry_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_index_;
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_term_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_commit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class AppendEntryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AppendEntryResponse) */ {
 public:
  inline AppendEntryResponse() : AppendEntryResponse(nullptr) {}
  ~AppendEntryResponse() override;
  explicit constexpr AppendEntryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntryResponse(const AppendEntryResponse& from);
  AppendEntryResponse(AppendEntryResponse&& from) noexcept
    : AppendEntryResponse() {
    *this = ::std::move(from);
  }

  inline AppendEntryResponse& operator=(const AppendEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntryResponse& operator=(AppendEntryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntryResponse* internal_default_instance() {
    return reinterpret_cast<const AppendEntryResponse*>(
               &_AppendEntryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AppendEntryResponse& a, AppendEntryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppendEntryResponse* New() const final {
    return new AppendEntryResponse();
  }

  AppendEntryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppendEntryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AppendEntryResponse";
  }
  protected:
  explicit AppendEntryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:AppendEntryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RequestVoteRequest) */ {
 public:
  inline RequestVoteRequest() : RequestVoteRequest(nullptr) {}
  ~RequestVoteRequest() override;
  explicit constexpr RequestVoteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteRequest(const RequestVoteRequest& from);
  RequestVoteRequest(RequestVoteRequest&& from) noexcept
    : RequestVoteRequest() {
    *this = ::std::move(from);
  }

  inline RequestVoteRequest& operator=(const RequestVoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteRequest& operator=(RequestVoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteRequest* internal_default_instance() {
    return reinterpret_cast<const RequestVoteRequest*>(
               &_RequestVoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RequestVoteRequest& a, RequestVoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteRequest* New() const final {
    return new RequestVoteRequest();
  }

  RequestVoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestVoteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RequestVoteRequest";
  }
  protected:
  explicit RequestVoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kCandidateIdFieldNumber = 2,
    kLastLogEntryFieldNumber = 3,
    kLastLogTermFieldNumber = 4,
  };
  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 candidate_id = 2;
  void clear_candidate_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 candidate_id() const;
  void set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_candidate_id() const;
  void _internal_set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 last_log_entry = 3;
  void clear_last_log_entry();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_entry() const;
  void set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_log_entry() const;
  void _internal_set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 last_log_term = 4;
  void clear_last_log_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_term() const;
  void set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_log_term() const;
  void _internal_set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:RequestVoteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  ::PROTOBUF_NAMESPACE_ID::uint64 candidate_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_entry_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_term_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RequestVoteResponse) */ {
 public:
  inline RequestVoteResponse() : RequestVoteResponse(nullptr) {}
  ~RequestVoteResponse() override;
  explicit constexpr RequestVoteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteResponse(const RequestVoteResponse& from);
  RequestVoteResponse(RequestVoteResponse&& from) noexcept
    : RequestVoteResponse() {
    *this = ::std::move(from);
  }

  inline RequestVoteResponse& operator=(const RequestVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteResponse& operator=(RequestVoteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteResponse* internal_default_instance() {
    return reinterpret_cast<const RequestVoteResponse*>(
               &_RequestVoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RequestVoteResponse& a, RequestVoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteResponse* New() const final {
    return new RequestVoteResponse();
  }

  RequestVoteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestVoteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RequestVoteResponse";
  }
  protected:
  explicit RequestVoteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kVoteGrantedFieldNumber = 2,
  };
  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool vote_granted = 2;
  void clear_vote_granted();
  bool vote_granted() const;
  void set_vote_granted(bool value);
  private:
  bool _internal_vote_granted() const;
  void _internal_set_vote_granted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RequestVoteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  bool vote_granted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class WorkerConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerConnectRequest) */ {
 public:
  inline WorkerConnectRequest() : WorkerConnectRequest(nullptr) {}
  ~WorkerConnectRequest() override;
  explicit constexpr WorkerConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerConnectRequest(const WorkerConnectRequest& from);
  WorkerConnectRequest(WorkerConnectRequest&& from) noexcept
    : WorkerConnectRequest() {
    *this = ::std::move(from);
  }

  inline WorkerConnectRequest& operator=(const WorkerConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerConnectRequest& operator=(WorkerConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerConnectRequest* internal_default_instance() {
    return reinterpret_cast<const WorkerConnectRequest*>(
               &_WorkerConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WorkerConnectRequest& a, WorkerConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerConnectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerConnectRequest* New() const final {
    return new WorkerConnectRequest();
  }

  WorkerConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerConnectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerConnectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerConnectRequest";
  }
  protected:
  explicit WorkerConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskResultFieldNumber = 3,
    kTaskIdFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // .TaskResult task_result = 3;
  bool has_task_result() const;
  private:
  bool _internal_has_task_result() const;
  public:
  void clear_task_result();
  const ::TaskResult& task_result() const;
  PROTOBUF_MUST_USE_RESULT ::TaskResult* release_task_result();
  ::TaskResult* mutable_task_result();
  void set_allocated_task_result(::TaskResult* task_result);
  private:
  const ::TaskResult& _internal_task_result() const;
  ::TaskResult* _internal_mutable_task_result();
  public:
  void unsafe_arena_set_allocated_task_result(
      ::TaskResult* task_result);
  ::TaskResult* unsafe_arena_release_task_result();

  // uint64 task_id = 2;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .WorkerStatus status = 1;
  void clear_status();
  ::WorkerStatus status() const;
  void set_status(::WorkerStatus value);
  private:
  ::WorkerStatus _internal_status() const;
  void _internal_set_status(::WorkerStatus value);
  public:

  // @@protoc_insertion_point(class_scope:WorkerConnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskResult* task_result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class WorkerConnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerConnectResponse) */ {
 public:
  inline WorkerConnectResponse() : WorkerConnectResponse(nullptr) {}
  ~WorkerConnectResponse() override;
  explicit constexpr WorkerConnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerConnectResponse(const WorkerConnectResponse& from);
  WorkerConnectResponse(WorkerConnectResponse&& from) noexcept
    : WorkerConnectResponse() {
    *this = ::std::move(from);
  }

  inline WorkerConnectResponse& operator=(const WorkerConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerConnectResponse& operator=(WorkerConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerConnectResponse* internal_default_instance() {
    return reinterpret_cast<const WorkerConnectResponse*>(
               &_WorkerConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(WorkerConnectResponse& a, WorkerConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerConnectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerConnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerConnectResponse* New() const final {
    return new WorkerConnectResponse();
  }

  WorkerConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerConnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerConnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerConnectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerConnectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerConnectResponse";
  }
  protected:
  explicit WorkerConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskDataFieldNumber = 4,
    kTaskResultFieldNumber = 5,
    kTaskIdFieldNumber = 2,
    kLeaderIdFieldNumber = 3,
    kCommandFieldNumber = 1,
  };
  // .TaskData task_data = 4;
  bool has_task_data() const;
  private:
  bool _internal_has_task_data() const;
  public:
  void clear_task_data();
  const ::TaskData& task_data() const;
  PROTOBUF_MUST_USE_RESULT ::TaskData* release_task_data();
  ::TaskData* mutable_task_data();
  void set_allocated_task_data(::TaskData* task_data);
  private:
  const ::TaskData& _internal_task_data() const;
  ::TaskData* _internal_mutable_task_data();
  public:
  void unsafe_arena_set_allocated_task_data(
      ::TaskData* task_data);
  ::TaskData* unsafe_arena_release_task_data();

  // .TaskResult task_result = 5;
  bool has_task_result() const;
  private:
  bool _internal_has_task_result() const;
  public:
  void clear_task_result();
  const ::TaskResult& task_result() const;
  PROTOBUF_MUST_USE_RESULT ::TaskResult* release_task_result();
  ::TaskResult* mutable_task_result();
  void set_allocated_task_result(::TaskResult* task_result);
  private:
  const ::TaskResult& _internal_task_result() const;
  ::TaskResult* _internal_mutable_task_result();
  public:
  void unsafe_arena_set_allocated_task_result(
      ::TaskResult* task_result);
  ::TaskResult* unsafe_arena_release_task_result();

  // uint64 task_id = 2;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 leader_id = 3;
  void clear_leader_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id() const;
  void set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_id() const;
  void _internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .WorkerCommand command = 1;
  void clear_command();
  ::WorkerCommand command() const;
  void set_command(::WorkerCommand value);
  private:
  ::WorkerCommand _internal_command() const;
  void _internal_set_command(::WorkerCommand value);
  public:

  // @@protoc_insertion_point(class_scope:WorkerConnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskData* task_data_;
  ::TaskResult* task_result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class AssignTaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AssignTaskRequest) */ {
 public:
  inline AssignTaskRequest() : AssignTaskRequest(nullptr) {}
  ~AssignTaskRequest() override;
  explicit constexpr AssignTaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssignTaskRequest(const AssignTaskRequest& from);
  AssignTaskRequest(AssignTaskRequest&& from) noexcept
    : AssignTaskRequest() {
    *this = ::std::move(from);
  }

  inline AssignTaskRequest& operator=(const AssignTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignTaskRequest& operator=(AssignTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssignTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignTaskRequest* internal_default_instance() {
    return reinterpret_cast<const AssignTaskRequest*>(
               &_AssignTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AssignTaskRequest& a, AssignTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AssignTaskRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignTaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AssignTaskRequest* New() const final {
    return new AssignTaskRequest();
  }

  AssignTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AssignTaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssignTaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AssignTaskRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AssignTaskRequest";
  }
  protected:
  explicit AssignTaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
  };
  // uint64 task_id = 1;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:AssignTaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class AssignTaskResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AssignTaskResponse) */ {
 public:
  inline AssignTaskResponse() : AssignTaskResponse(nullptr) {}
  ~AssignTaskResponse() override;
  explicit constexpr AssignTaskResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssignTaskResponse(const AssignTaskResponse& from);
  AssignTaskResponse(AssignTaskResponse&& from) noexcept
    : AssignTaskResponse() {
    *this = ::std::move(from);
  }

  inline AssignTaskResponse& operator=(const AssignTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignTaskResponse& operator=(AssignTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssignTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignTaskResponse* internal_default_instance() {
    return reinterpret_cast<const AssignTaskResponse*>(
               &_AssignTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AssignTaskResponse& a, AssignTaskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AssignTaskResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignTaskResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AssignTaskResponse* New() const final {
    return new AssignTaskResponse();
  }

  AssignTaskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AssignTaskResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssignTaskResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AssignTaskResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignTaskResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AssignTaskResponse";
  }
  protected:
  explicit AssignTaskResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkerIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // uint64 worker_id = 2;
  void clear_worker_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 worker_id() const;
  void set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_worker_id() const;
  void _internal_set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:AssignTaskResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 worker_id_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class SendTaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SendTaskRequest) */ {
 public:
  inline SendTaskRequest() : SendTaskRequest(nullptr) {}
  ~SendTaskRequest() override;
  explicit constexpr SendTaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendTaskRequest(const SendTaskRequest& from);
  SendTaskRequest(SendTaskRequest&& from) noexcept
    : SendTaskRequest() {
    *this = ::std::move(from);
  }

  inline SendTaskRequest& operator=(const SendTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendTaskRequest& operator=(SendTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendTaskRequest* internal_default_instance() {
    return reinterpret_cast<const SendTaskRequest*>(
               &_SendTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SendTaskRequest& a, SendTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendTaskRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendTaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendTaskRequest* New() const final {
    return new SendTaskRequest();
  }

  SendTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendTaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendTaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendTaskRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SendTaskRequest";
  }
  protected:
  explicit SendTaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 1,
  };
  // .Task task = 1;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::Task& task() const;
  PROTOBUF_MUST_USE_RESULT ::Task* release_task();
  ::Task* mutable_task();
  void set_allocated_task(::Task* task);
  private:
  const ::Task& _internal_task() const;
  ::Task* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::Task* task);
  ::Task* unsafe_arena_release_task();

  // @@protoc_insertion_point(class_scope:SendTaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Task* task_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class SendTaskResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SendTaskResponse) */ {
 public:
  inline SendTaskResponse() : SendTaskResponse(nullptr) {}
  ~SendTaskResponse() override;
  explicit constexpr SendTaskResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendTaskResponse(const SendTaskResponse& from);
  SendTaskResponse(SendTaskResponse&& from) noexcept
    : SendTaskResponse() {
    *this = ::std::move(from);
  }

  inline SendTaskResponse& operator=(const SendTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendTaskResponse& operator=(SendTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendTaskResponse* internal_default_instance() {
    return reinterpret_cast<const SendTaskResponse*>(
               &_SendTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SendTaskResponse& a, SendTaskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendTaskResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendTaskResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendTaskResponse* New() const final {
    return new SendTaskResponse();
  }

  SendTaskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendTaskResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendTaskResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendTaskResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendTaskResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SendTaskResponse";
  }
  protected:
  explicit SendTaskResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SendTaskResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class GetWorkerResultRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetWorkerResultRequest) */ {
 public:
  inline GetWorkerResultRequest() : GetWorkerResultRequest(nullptr) {}
  ~GetWorkerResultRequest() override;
  explicit constexpr GetWorkerResultRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWorkerResultRequest(const GetWorkerResultRequest& from);
  GetWorkerResultRequest(GetWorkerResultRequest&& from) noexcept
    : GetWorkerResultRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkerResultRequest& operator=(const GetWorkerResultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkerResultRequest& operator=(GetWorkerResultRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkerResultRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkerResultRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkerResultRequest*>(
               &_GetWorkerResultRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetWorkerResultRequest& a, GetWorkerResultRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkerResultRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkerResultRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetWorkerResultRequest* New() const final {
    return new GetWorkerResultRequest();
  }

  GetWorkerResultRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetWorkerResultRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWorkerResultRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetWorkerResultRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkerResultRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetWorkerResultRequest";
  }
  protected:
  explicit GetWorkerResultRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkerIdFieldNumber = 1,
    kTaskIdFieldNumber = 2,
  };
  // uint64 worker_id = 1;
  void clear_worker_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 worker_id() const;
  void set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_worker_id() const;
  void _internal_set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 task_id = 2;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:GetWorkerResultRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 worker_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class GetWorkerResultResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetWorkerResultResponse) */ {
 public:
  inline GetWorkerResultResponse() : GetWorkerResultResponse(nullptr) {}
  ~GetWorkerResultResponse() override;
  explicit constexpr GetWorkerResultResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWorkerResultResponse(const GetWorkerResultResponse& from);
  GetWorkerResultResponse(GetWorkerResultResponse&& from) noexcept
    : GetWorkerResultResponse() {
    *this = ::std::move(from);
  }

  inline GetWorkerResultResponse& operator=(const GetWorkerResultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkerResultResponse& operator=(GetWorkerResultResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkerResultResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkerResultResponse* internal_default_instance() {
    return reinterpret_cast<const GetWorkerResultResponse*>(
               &_GetWorkerResultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetWorkerResultResponse& a, GetWorkerResultResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkerResultResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkerResultResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetWorkerResultResponse* New() const final {
    return new GetWorkerResultResponse();
  }

  GetWorkerResultResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetWorkerResultResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWorkerResultResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetWorkerResultResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkerResultResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetWorkerResultResponse";
  }
  protected:
  explicit GetWorkerResultResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskResultFieldNumber = 2,
  };
  // .TaskResult task_result = 2;
  bool has_task_result() const;
  private:
  bool _internal_has_task_result() const;
  public:
  void clear_task_result();
  const ::TaskResult& task_result() const;
  PROTOBUF_MUST_USE_RESULT ::TaskResult* release_task_result();
  ::TaskResult* mutable_task_result();
  void set_allocated_task_result(::TaskResult* task_result);
  private:
  const ::TaskResult& _internal_task_result() const;
  ::TaskResult* _internal_mutable_task_result();
  public:
  void unsafe_arena_set_allocated_task_result(
      ::TaskResult* task_result);
  ::TaskResult* unsafe_arena_release_task_result();

  // @@protoc_insertion_point(class_scope:GetWorkerResultResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskResult* task_result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// TaskData

// repeated int32 data = 1;
inline int TaskData::_internal_data_size() const {
  return data_.size();
}
inline int TaskData::data_size() const {
  return _internal_data_size();
}
inline void TaskData::clear_data() {
  data_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskData::_internal_data(int index) const {
  return data_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskData::data(int index) const {
  // @@protoc_insertion_point(field_get:TaskData.data)
  return _internal_data(index);
}
inline void TaskData::set_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:TaskData.data)
}
inline void TaskData::_internal_add_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  data_.Add(value);
}
inline void TaskData::add_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:TaskData.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TaskData::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TaskData::data() const {
  // @@protoc_insertion_point(field_list:TaskData.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TaskData::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TaskData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:TaskData.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// TaskResult

// int32 result = 1;
inline void TaskResult::clear_result() {
  result_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskResult::_internal_result() const {
  return result_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskResult::result() const {
  // @@protoc_insertion_point(field_get:TaskResult.result)
  return _internal_result();
}
inline void TaskResult::_internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  result_ = value;
}
inline void TaskResult::set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:TaskResult.result)
}

// -------------------------------------------------------------------

// UserConnectRequest

// .UserStatus status = 1;
inline void UserConnectRequest::clear_status() {
  status_ = 0;
}
inline ::UserStatus UserConnectRequest::_internal_status() const {
  return static_cast< ::UserStatus >(status_);
}
inline ::UserStatus UserConnectRequest::status() const {
  // @@protoc_insertion_point(field_get:UserConnectRequest.status)
  return _internal_status();
}
inline void UserConnectRequest::_internal_set_status(::UserStatus value) {
  
  status_ = value;
}
inline void UserConnectRequest::set_status(::UserStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:UserConnectRequest.status)
}

// .TaskData task_data = 2;
inline bool UserConnectRequest::_internal_has_task_data() const {
  return this != internal_default_instance() && task_data_ != nullptr;
}
inline bool UserConnectRequest::has_task_data() const {
  return _internal_has_task_data();
}
inline void UserConnectRequest::clear_task_data() {
  if (GetArenaForAllocation() == nullptr && task_data_ != nullptr) {
    delete task_data_;
  }
  task_data_ = nullptr;
}
inline const ::TaskData& UserConnectRequest::_internal_task_data() const {
  const ::TaskData* p = task_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskData&>(
      ::_TaskData_default_instance_);
}
inline const ::TaskData& UserConnectRequest::task_data() const {
  // @@protoc_insertion_point(field_get:UserConnectRequest.task_data)
  return _internal_task_data();
}
inline void UserConnectRequest::unsafe_arena_set_allocated_task_data(
    ::TaskData* task_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_data_);
  }
  task_data_ = task_data;
  if (task_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserConnectRequest.task_data)
}
inline ::TaskData* UserConnectRequest::release_task_data() {
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskData* UserConnectRequest::unsafe_arena_release_task_data() {
  // @@protoc_insertion_point(field_release:UserConnectRequest.task_data)
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
  return temp;
}
inline ::TaskData* UserConnectRequest::_internal_mutable_task_data() {
  
  if (task_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskData>(GetArenaForAllocation());
    task_data_ = p;
  }
  return task_data_;
}
inline ::TaskData* UserConnectRequest::mutable_task_data() {
  ::TaskData* _msg = _internal_mutable_task_data();
  // @@protoc_insertion_point(field_mutable:UserConnectRequest.task_data)
  return _msg;
}
inline void UserConnectRequest::set_allocated_task_data(::TaskData* task_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_data_;
  }
  if (task_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskData>::GetOwningArena(task_data);
    if (message_arena != submessage_arena) {
      task_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_data, submessage_arena);
    }
    
  } else {
    
  }
  task_data_ = task_data;
  // @@protoc_insertion_point(field_set_allocated:UserConnectRequest.task_data)
}

// -------------------------------------------------------------------

// UploadDataRequest

// .TaskData task_data = 1;
inline bool UploadDataRequest::_internal_has_task_data() const {
  return this != internal_default_instance() && task_data_ != nullptr;
}
inline bool UploadDataRequest::has_task_data() const {
  return _internal_has_task_data();
}
inline void UploadDataRequest::clear_task_data() {
  if (GetArenaForAllocation() == nullptr && task_data_ != nullptr) {
    delete task_data_;
  }
  task_data_ = nullptr;
}
inline const ::TaskData& UploadDataRequest::_internal_task_data() const {
  const ::TaskData* p = task_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskData&>(
      ::_TaskData_default_instance_);
}
inline const ::TaskData& UploadDataRequest::task_data() const {
  // @@protoc_insertion_point(field_get:UploadDataRequest.task_data)
  return _internal_task_data();
}
inline void UploadDataRequest::unsafe_arena_set_allocated_task_data(
    ::TaskData* task_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_data_);
  }
  task_data_ = task_data;
  if (task_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UploadDataRequest.task_data)
}
inline ::TaskData* UploadDataRequest::release_task_data() {
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskData* UploadDataRequest::unsafe_arena_release_task_data() {
  // @@protoc_insertion_point(field_release:UploadDataRequest.task_data)
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
  return temp;
}
inline ::TaskData* UploadDataRequest::_internal_mutable_task_data() {
  
  if (task_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskData>(GetArenaForAllocation());
    task_data_ = p;
  }
  return task_data_;
}
inline ::TaskData* UploadDataRequest::mutable_task_data() {
  ::TaskData* _msg = _internal_mutable_task_data();
  // @@protoc_insertion_point(field_mutable:UploadDataRequest.task_data)
  return _msg;
}
inline void UploadDataRequest::set_allocated_task_data(::TaskData* task_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_data_;
  }
  if (task_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskData>::GetOwningArena(task_data);
    if (message_arena != submessage_arena) {
      task_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_data, submessage_arena);
    }
    
  } else {
    
  }
  task_data_ = task_data;
  // @@protoc_insertion_point(field_set_allocated:UploadDataRequest.task_data)
}

// -------------------------------------------------------------------

// UploadDataResponse

// bool success = 1;
inline void UploadDataResponse::clear_success() {
  success_ = false;
}
inline bool UploadDataResponse::_internal_success() const {
  return success_;
}
inline bool UploadDataResponse::success() const {
  // @@protoc_insertion_point(field_get:UploadDataResponse.success)
  return _internal_success();
}
inline void UploadDataResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void UploadDataResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:UploadDataResponse.success)
}

// uint64 task_id = 2;
inline void UploadDataResponse::clear_task_id() {
  task_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UploadDataResponse::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UploadDataResponse::task_id() const {
  // @@protoc_insertion_point(field_get:UploadDataResponse.task_id)
  return _internal_task_id();
}
inline void UploadDataResponse::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  task_id_ = value;
}
inline void UploadDataResponse::set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:UploadDataResponse.task_id)
}

// -------------------------------------------------------------------

// UserConnectResponse

// .UserCommand command = 1;
inline void UserConnectResponse::clear_command() {
  command_ = 0;
}
inline ::UserCommand UserConnectResponse::_internal_command() const {
  return static_cast< ::UserCommand >(command_);
}
inline ::UserCommand UserConnectResponse::command() const {
  // @@protoc_insertion_point(field_get:UserConnectResponse.command)
  return _internal_command();
}
inline void UserConnectResponse::_internal_set_command(::UserCommand value) {
  
  command_ = value;
}
inline void UserConnectResponse::set_command(::UserCommand value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:UserConnectResponse.command)
}

// uint64 leader_id = 2;
inline void UserConnectResponse::clear_leader_id() {
  leader_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserConnectResponse::_internal_leader_id() const {
  return leader_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserConnectResponse::leader_id() const {
  // @@protoc_insertion_point(field_get:UserConnectResponse.leader_id)
  return _internal_leader_id();
}
inline void UserConnectResponse::_internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_id_ = value;
}
inline void UserConnectResponse::set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_id(value);
  // @@protoc_insertion_point(field_set:UserConnectResponse.leader_id)
}

// .TaskResult task_result = 3;
inline bool UserConnectResponse::_internal_has_task_result() const {
  return this != internal_default_instance() && task_result_ != nullptr;
}
inline bool UserConnectResponse::has_task_result() const {
  return _internal_has_task_result();
}
inline void UserConnectResponse::clear_task_result() {
  if (GetArenaForAllocation() == nullptr && task_result_ != nullptr) {
    delete task_result_;
  }
  task_result_ = nullptr;
}
inline const ::TaskResult& UserConnectResponse::_internal_task_result() const {
  const ::TaskResult* p = task_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskResult&>(
      ::_TaskResult_default_instance_);
}
inline const ::TaskResult& UserConnectResponse::task_result() const {
  // @@protoc_insertion_point(field_get:UserConnectResponse.task_result)
  return _internal_task_result();
}
inline void UserConnectResponse::unsafe_arena_set_allocated_task_result(
    ::TaskResult* task_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_result_);
  }
  task_result_ = task_result;
  if (task_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserConnectResponse.task_result)
}
inline ::TaskResult* UserConnectResponse::release_task_result() {
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskResult* UserConnectResponse::unsafe_arena_release_task_result() {
  // @@protoc_insertion_point(field_release:UserConnectResponse.task_result)
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
  return temp;
}
inline ::TaskResult* UserConnectResponse::_internal_mutable_task_result() {
  
  if (task_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskResult>(GetArenaForAllocation());
    task_result_ = p;
  }
  return task_result_;
}
inline ::TaskResult* UserConnectResponse::mutable_task_result() {
  ::TaskResult* _msg = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:UserConnectResponse.task_result)
  return _msg;
}
inline void UserConnectResponse::set_allocated_task_result(::TaskResult* task_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_result_;
  }
  if (task_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskResult>::GetOwningArena(task_result);
    if (message_arena != submessage_arena) {
      task_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_result, submessage_arena);
    }
    
  } else {
    
  }
  task_result_ = task_result;
  // @@protoc_insertion_point(field_set_allocated:UserConnectResponse.task_result)
}

// .UploadDataResponse upload_data_response = 4;
inline bool UserConnectResponse::_internal_has_upload_data_response() const {
  return this != internal_default_instance() && upload_data_response_ != nullptr;
}
inline bool UserConnectResponse::has_upload_data_response() const {
  return _internal_has_upload_data_response();
}
inline void UserConnectResponse::clear_upload_data_response() {
  if (GetArenaForAllocation() == nullptr && upload_data_response_ != nullptr) {
    delete upload_data_response_;
  }
  upload_data_response_ = nullptr;
}
inline const ::UploadDataResponse& UserConnectResponse::_internal_upload_data_response() const {
  const ::UploadDataResponse* p = upload_data_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::UploadDataResponse&>(
      ::_UploadDataResponse_default_instance_);
}
inline const ::UploadDataResponse& UserConnectResponse::upload_data_response() const {
  // @@protoc_insertion_point(field_get:UserConnectResponse.upload_data_response)
  return _internal_upload_data_response();
}
inline void UserConnectResponse::unsafe_arena_set_allocated_upload_data_response(
    ::UploadDataResponse* upload_data_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(upload_data_response_);
  }
  upload_data_response_ = upload_data_response;
  if (upload_data_response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserConnectResponse.upload_data_response)
}
inline ::UploadDataResponse* UserConnectResponse::release_upload_data_response() {
  
  ::UploadDataResponse* temp = upload_data_response_;
  upload_data_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UploadDataResponse* UserConnectResponse::unsafe_arena_release_upload_data_response() {
  // @@protoc_insertion_point(field_release:UserConnectResponse.upload_data_response)
  
  ::UploadDataResponse* temp = upload_data_response_;
  upload_data_response_ = nullptr;
  return temp;
}
inline ::UploadDataResponse* UserConnectResponse::_internal_mutable_upload_data_response() {
  
  if (upload_data_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::UploadDataResponse>(GetArenaForAllocation());
    upload_data_response_ = p;
  }
  return upload_data_response_;
}
inline ::UploadDataResponse* UserConnectResponse::mutable_upload_data_response() {
  ::UploadDataResponse* _msg = _internal_mutable_upload_data_response();
  // @@protoc_insertion_point(field_mutable:UserConnectResponse.upload_data_response)
  return _msg;
}
inline void UserConnectResponse::set_allocated_upload_data_response(::UploadDataResponse* upload_data_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete upload_data_response_;
  }
  if (upload_data_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::UploadDataResponse>::GetOwningArena(upload_data_response);
    if (message_arena != submessage_arena) {
      upload_data_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upload_data_response, submessage_arena);
    }
    
  } else {
    
  }
  upload_data_response_ = upload_data_response;
  // @@protoc_insertion_point(field_set_allocated:UserConnectResponse.upload_data_response)
}

// -------------------------------------------------------------------

// Task

// uint64 id = 1;
inline void Task::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Task::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Task::id() const {
  // @@protoc_insertion_point(field_get:Task.id)
  return _internal_id();
}
inline void Task::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Task::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Task.id)
}

// uint64 assignee = 2;
inline void Task::clear_assignee() {
  assignee_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Task::_internal_assignee() const {
  return assignee_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Task::assignee() const {
  // @@protoc_insertion_point(field_get:Task.assignee)
  return _internal_assignee();
}
inline void Task::_internal_set_assignee(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  assignee_ = value;
}
inline void Task::set_assignee(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_assignee(value);
  // @@protoc_insertion_point(field_set:Task.assignee)
}

// .TaskData task_data = 3;
inline bool Task::_internal_has_task_data() const {
  return this != internal_default_instance() && task_data_ != nullptr;
}
inline bool Task::has_task_data() const {
  return _internal_has_task_data();
}
inline void Task::clear_task_data() {
  if (GetArenaForAllocation() == nullptr && task_data_ != nullptr) {
    delete task_data_;
  }
  task_data_ = nullptr;
}
inline const ::TaskData& Task::_internal_task_data() const {
  const ::TaskData* p = task_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskData&>(
      ::_TaskData_default_instance_);
}
inline const ::TaskData& Task::task_data() const {
  // @@protoc_insertion_point(field_get:Task.task_data)
  return _internal_task_data();
}
inline void Task::unsafe_arena_set_allocated_task_data(
    ::TaskData* task_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_data_);
  }
  task_data_ = task_data;
  if (task_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Task.task_data)
}
inline ::TaskData* Task::release_task_data() {
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskData* Task::unsafe_arena_release_task_data() {
  // @@protoc_insertion_point(field_release:Task.task_data)
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
  return temp;
}
inline ::TaskData* Task::_internal_mutable_task_data() {
  
  if (task_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskData>(GetArenaForAllocation());
    task_data_ = p;
  }
  return task_data_;
}
inline ::TaskData* Task::mutable_task_data() {
  ::TaskData* _msg = _internal_mutable_task_data();
  // @@protoc_insertion_point(field_mutable:Task.task_data)
  return _msg;
}
inline void Task::set_allocated_task_data(::TaskData* task_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_data_;
  }
  if (task_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskData>::GetOwningArena(task_data);
    if (message_arena != submessage_arena) {
      task_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_data, submessage_arena);
    }
    
  } else {
    
  }
  task_data_ = task_data;
  // @@protoc_insertion_point(field_set_allocated:Task.task_data)
}

// .TaskResult task_result = 4;
inline bool Task::_internal_has_task_result() const {
  return this != internal_default_instance() && task_result_ != nullptr;
}
inline bool Task::has_task_result() const {
  return _internal_has_task_result();
}
inline void Task::clear_task_result() {
  if (GetArenaForAllocation() == nullptr && task_result_ != nullptr) {
    delete task_result_;
  }
  task_result_ = nullptr;
}
inline const ::TaskResult& Task::_internal_task_result() const {
  const ::TaskResult* p = task_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskResult&>(
      ::_TaskResult_default_instance_);
}
inline const ::TaskResult& Task::task_result() const {
  // @@protoc_insertion_point(field_get:Task.task_result)
  return _internal_task_result();
}
inline void Task::unsafe_arena_set_allocated_task_result(
    ::TaskResult* task_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_result_);
  }
  task_result_ = task_result;
  if (task_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Task.task_result)
}
inline ::TaskResult* Task::release_task_result() {
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskResult* Task::unsafe_arena_release_task_result() {
  // @@protoc_insertion_point(field_release:Task.task_result)
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
  return temp;
}
inline ::TaskResult* Task::_internal_mutable_task_result() {
  
  if (task_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskResult>(GetArenaForAllocation());
    task_result_ = p;
  }
  return task_result_;
}
inline ::TaskResult* Task::mutable_task_result() {
  ::TaskResult* _msg = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:Task.task_result)
  return _msg;
}
inline void Task::set_allocated_task_result(::TaskResult* task_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_result_;
  }
  if (task_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskResult>::GetOwningArena(task_result);
    if (message_arena != submessage_arena) {
      task_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_result, submessage_arena);
    }
    
  } else {
    
  }
  task_result_ = task_result;
  // @@protoc_insertion_point(field_set_allocated:Task.task_result)
}

// -------------------------------------------------------------------

// AddRequest

// .TaskStatus to = 1;
inline void AddRequest::clear_to() {
  to_ = 0;
}
inline ::TaskStatus AddRequest::_internal_to() const {
  return static_cast< ::TaskStatus >(to_);
}
inline ::TaskStatus AddRequest::to() const {
  // @@protoc_insertion_point(field_get:AddRequest.to)
  return _internal_to();
}
inline void AddRequest::_internal_set_to(::TaskStatus value) {
  
  to_ = value;
}
inline void AddRequest::set_to(::TaskStatus value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:AddRequest.to)
}

// -------------------------------------------------------------------

// MoveRequest

// .TaskStatus to = 1;
inline void MoveRequest::clear_to() {
  to_ = 0;
}
inline ::TaskStatus MoveRequest::_internal_to() const {
  return static_cast< ::TaskStatus >(to_);
}
inline ::TaskStatus MoveRequest::to() const {
  // @@protoc_insertion_point(field_get:MoveRequest.to)
  return _internal_to();
}
inline void MoveRequest::_internal_set_to(::TaskStatus value) {
  
  to_ = value;
}
inline void MoveRequest::set_to(::TaskStatus value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:MoveRequest.to)
}

// .TaskStatus from = 2;
inline void MoveRequest::clear_from() {
  from_ = 0;
}
inline ::TaskStatus MoveRequest::_internal_from() const {
  return static_cast< ::TaskStatus >(from_);
}
inline ::TaskStatus MoveRequest::from() const {
  // @@protoc_insertion_point(field_get:MoveRequest.from)
  return _internal_from();
}
inline void MoveRequest::_internal_set_from(::TaskStatus value) {
  
  from_ = value;
}
inline void MoveRequest::set_from(::TaskStatus value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:MoveRequest.from)
}

// -------------------------------------------------------------------

// DeleteRequest

// .TaskStatus from = 1;
inline void DeleteRequest::clear_from() {
  from_ = 0;
}
inline ::TaskStatus DeleteRequest::_internal_from() const {
  return static_cast< ::TaskStatus >(from_);
}
inline ::TaskStatus DeleteRequest::from() const {
  // @@protoc_insertion_point(field_get:DeleteRequest.from)
  return _internal_from();
}
inline void DeleteRequest::_internal_set_from(::TaskStatus value) {
  
  from_ = value;
}
inline void DeleteRequest::set_from(::TaskStatus value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:DeleteRequest.from)
}

// -------------------------------------------------------------------

// Command

// .Command.CommandType command = 1;
inline void Command::clear_command() {
  command_ = 0;
}
inline ::Command_CommandType Command::_internal_command() const {
  return static_cast< ::Command_CommandType >(command_);
}
inline ::Command_CommandType Command::command() const {
  // @@protoc_insertion_point(field_get:Command.command)
  return _internal_command();
}
inline void Command::_internal_set_command(::Command_CommandType value) {
  
  command_ = value;
}
inline void Command::set_command(::Command_CommandType value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:Command.command)
}

// .AddRequest add_request = 2;
inline bool Command::_internal_has_add_request() const {
  return this != internal_default_instance() && add_request_ != nullptr;
}
inline bool Command::has_add_request() const {
  return _internal_has_add_request();
}
inline void Command::clear_add_request() {
  if (GetArenaForAllocation() == nullptr && add_request_ != nullptr) {
    delete add_request_;
  }
  add_request_ = nullptr;
}
inline const ::AddRequest& Command::_internal_add_request() const {
  const ::AddRequest* p = add_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::AddRequest&>(
      ::_AddRequest_default_instance_);
}
inline const ::AddRequest& Command::add_request() const {
  // @@protoc_insertion_point(field_get:Command.add_request)
  return _internal_add_request();
}
inline void Command::unsafe_arena_set_allocated_add_request(
    ::AddRequest* add_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(add_request_);
  }
  add_request_ = add_request;
  if (add_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.add_request)
}
inline ::AddRequest* Command::release_add_request() {
  
  ::AddRequest* temp = add_request_;
  add_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AddRequest* Command::unsafe_arena_release_add_request() {
  // @@protoc_insertion_point(field_release:Command.add_request)
  
  ::AddRequest* temp = add_request_;
  add_request_ = nullptr;
  return temp;
}
inline ::AddRequest* Command::_internal_mutable_add_request() {
  
  if (add_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::AddRequest>(GetArenaForAllocation());
    add_request_ = p;
  }
  return add_request_;
}
inline ::AddRequest* Command::mutable_add_request() {
  ::AddRequest* _msg = _internal_mutable_add_request();
  // @@protoc_insertion_point(field_mutable:Command.add_request)
  return _msg;
}
inline void Command::set_allocated_add_request(::AddRequest* add_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete add_request_;
  }
  if (add_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AddRequest>::GetOwningArena(add_request);
    if (message_arena != submessage_arena) {
      add_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_request, submessage_arena);
    }
    
  } else {
    
  }
  add_request_ = add_request;
  // @@protoc_insertion_point(field_set_allocated:Command.add_request)
}

// .MoveRequest move_request = 3;
inline bool Command::_internal_has_move_request() const {
  return this != internal_default_instance() && move_request_ != nullptr;
}
inline bool Command::has_move_request() const {
  return _internal_has_move_request();
}
inline void Command::clear_move_request() {
  if (GetArenaForAllocation() == nullptr && move_request_ != nullptr) {
    delete move_request_;
  }
  move_request_ = nullptr;
}
inline const ::MoveRequest& Command::_internal_move_request() const {
  const ::MoveRequest* p = move_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::MoveRequest&>(
      ::_MoveRequest_default_instance_);
}
inline const ::MoveRequest& Command::move_request() const {
  // @@protoc_insertion_point(field_get:Command.move_request)
  return _internal_move_request();
}
inline void Command::unsafe_arena_set_allocated_move_request(
    ::MoveRequest* move_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(move_request_);
  }
  move_request_ = move_request;
  if (move_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.move_request)
}
inline ::MoveRequest* Command::release_move_request() {
  
  ::MoveRequest* temp = move_request_;
  move_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MoveRequest* Command::unsafe_arena_release_move_request() {
  // @@protoc_insertion_point(field_release:Command.move_request)
  
  ::MoveRequest* temp = move_request_;
  move_request_ = nullptr;
  return temp;
}
inline ::MoveRequest* Command::_internal_mutable_move_request() {
  
  if (move_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::MoveRequest>(GetArenaForAllocation());
    move_request_ = p;
  }
  return move_request_;
}
inline ::MoveRequest* Command::mutable_move_request() {
  ::MoveRequest* _msg = _internal_mutable_move_request();
  // @@protoc_insertion_point(field_mutable:Command.move_request)
  return _msg;
}
inline void Command::set_allocated_move_request(::MoveRequest* move_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete move_request_;
  }
  if (move_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MoveRequest>::GetOwningArena(move_request);
    if (message_arena != submessage_arena) {
      move_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move_request, submessage_arena);
    }
    
  } else {
    
  }
  move_request_ = move_request;
  // @@protoc_insertion_point(field_set_allocated:Command.move_request)
}

// .DeleteRequest delete_request = 4;
inline bool Command::_internal_has_delete_request() const {
  return this != internal_default_instance() && delete_request_ != nullptr;
}
inline bool Command::has_delete_request() const {
  return _internal_has_delete_request();
}
inline void Command::clear_delete_request() {
  if (GetArenaForAllocation() == nullptr && delete_request_ != nullptr) {
    delete delete_request_;
  }
  delete_request_ = nullptr;
}
inline const ::DeleteRequest& Command::_internal_delete_request() const {
  const ::DeleteRequest* p = delete_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::DeleteRequest&>(
      ::_DeleteRequest_default_instance_);
}
inline const ::DeleteRequest& Command::delete_request() const {
  // @@protoc_insertion_point(field_get:Command.delete_request)
  return _internal_delete_request();
}
inline void Command::unsafe_arena_set_allocated_delete_request(
    ::DeleteRequest* delete_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_request_);
  }
  delete_request_ = delete_request;
  if (delete_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.delete_request)
}
inline ::DeleteRequest* Command::release_delete_request() {
  
  ::DeleteRequest* temp = delete_request_;
  delete_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DeleteRequest* Command::unsafe_arena_release_delete_request() {
  // @@protoc_insertion_point(field_release:Command.delete_request)
  
  ::DeleteRequest* temp = delete_request_;
  delete_request_ = nullptr;
  return temp;
}
inline ::DeleteRequest* Command::_internal_mutable_delete_request() {
  
  if (delete_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::DeleteRequest>(GetArenaForAllocation());
    delete_request_ = p;
  }
  return delete_request_;
}
inline ::DeleteRequest* Command::mutable_delete_request() {
  ::DeleteRequest* _msg = _internal_mutable_delete_request();
  // @@protoc_insertion_point(field_mutable:Command.delete_request)
  return _msg;
}
inline void Command::set_allocated_delete_request(::DeleteRequest* delete_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete delete_request_;
  }
  if (delete_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DeleteRequest>::GetOwningArena(delete_request);
    if (message_arena != submessage_arena) {
      delete_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_request, submessage_arena);
    }
    
  } else {
    
  }
  delete_request_ = delete_request;
  // @@protoc_insertion_point(field_set_allocated:Command.delete_request)
}

// -------------------------------------------------------------------

// Entry

// uint64 term = 1;
inline void Entry::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Entry::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Entry::term() const {
  // @@protoc_insertion_point(field_get:Entry.term)
  return _internal_term();
}
inline void Entry::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void Entry::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:Entry.term)
}

// .Task task = 2;
inline bool Entry::_internal_has_task() const {
  return this != internal_default_instance() && task_ != nullptr;
}
inline bool Entry::has_task() const {
  return _internal_has_task();
}
inline void Entry::clear_task() {
  if (GetArenaForAllocation() == nullptr && task_ != nullptr) {
    delete task_;
  }
  task_ = nullptr;
}
inline const ::Task& Entry::_internal_task() const {
  const ::Task* p = task_;
  return p != nullptr ? *p : reinterpret_cast<const ::Task&>(
      ::_Task_default_instance_);
}
inline const ::Task& Entry::task() const {
  // @@protoc_insertion_point(field_get:Entry.task)
  return _internal_task();
}
inline void Entry::unsafe_arena_set_allocated_task(
    ::Task* task) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_);
  }
  task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Entry.task)
}
inline ::Task* Entry::release_task() {
  
  ::Task* temp = task_;
  task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Task* Entry::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:Entry.task)
  
  ::Task* temp = task_;
  task_ = nullptr;
  return temp;
}
inline ::Task* Entry::_internal_mutable_task() {
  
  if (task_ == nullptr) {
    auto* p = CreateMaybeMessage<::Task>(GetArenaForAllocation());
    task_ = p;
  }
  return task_;
}
inline ::Task* Entry::mutable_task() {
  ::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:Entry.task)
  return _msg;
}
inline void Entry::set_allocated_task(::Task* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_;
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Task>::GetOwningArena(task);
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:Entry.task)
}

// .Command command = 3;
inline bool Entry::_internal_has_command() const {
  return this != internal_default_instance() && command_ != nullptr;
}
inline bool Entry::has_command() const {
  return _internal_has_command();
}
inline void Entry::clear_command() {
  if (GetArenaForAllocation() == nullptr && command_ != nullptr) {
    delete command_;
  }
  command_ = nullptr;
}
inline const ::Command& Entry::_internal_command() const {
  const ::Command* p = command_;
  return p != nullptr ? *p : reinterpret_cast<const ::Command&>(
      ::_Command_default_instance_);
}
inline const ::Command& Entry::command() const {
  // @@protoc_insertion_point(field_get:Entry.command)
  return _internal_command();
}
inline void Entry::unsafe_arena_set_allocated_command(
    ::Command* command) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  command_ = command;
  if (command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Entry.command)
}
inline ::Command* Entry::release_command() {
  
  ::Command* temp = command_;
  command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Command* Entry::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:Entry.command)
  
  ::Command* temp = command_;
  command_ = nullptr;
  return temp;
}
inline ::Command* Entry::_internal_mutable_command() {
  
  if (command_ == nullptr) {
    auto* p = CreateMaybeMessage<::Command>(GetArenaForAllocation());
    command_ = p;
  }
  return command_;
}
inline ::Command* Entry::mutable_command() {
  ::Command* _msg = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:Entry.command)
  return _msg;
}
inline void Entry::set_allocated_command(::Command* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete command_;
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Command>::GetOwningArena(command);
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:Entry.command)
}

// -------------------------------------------------------------------

// AppendEntryRequest

// uint64 term = 1;
inline void AppendEntryRequest::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::term() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.term)
  return _internal_term();
}
inline void AppendEntryRequest::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void AppendEntryRequest::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.term)
}

// uint64 leader_id = 2;
inline void AppendEntryRequest::clear_leader_id() {
  leader_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_leader_id() const {
  return leader_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::leader_id() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.leader_id)
  return _internal_leader_id();
}
inline void AppendEntryRequest::_internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_id_ = value;
}
inline void AppendEntryRequest::set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_id(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.leader_id)
}

// uint64 prev_log_index = 3;
inline void AppendEntryRequest::clear_prev_log_index() {
  prev_log_index_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_prev_log_index() const {
  return prev_log_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::prev_log_index() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.prev_log_index)
  return _internal_prev_log_index();
}
inline void AppendEntryRequest::_internal_set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  prev_log_index_ = value;
}
inline void AppendEntryRequest::set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_prev_log_index(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.prev_log_index)
}

// uint64 prev_log_term = 4;
inline void AppendEntryRequest::clear_prev_log_term() {
  prev_log_term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_prev_log_term() const {
  return prev_log_term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::prev_log_term() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.prev_log_term)
  return _internal_prev_log_term();
}
inline void AppendEntryRequest::_internal_set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  prev_log_term_ = value;
}
inline void AppendEntryRequest::set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_prev_log_term(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.prev_log_term)
}

// .Entry entry = 5;
inline bool AppendEntryRequest::_internal_has_entry() const {
  return this != internal_default_instance() && entry_ != nullptr;
}
inline bool AppendEntryRequest::has_entry() const {
  return _internal_has_entry();
}
inline void AppendEntryRequest::clear_entry() {
  if (GetArenaForAllocation() == nullptr && entry_ != nullptr) {
    delete entry_;
  }
  entry_ = nullptr;
}
inline const ::Entry& AppendEntryRequest::_internal_entry() const {
  const ::Entry* p = entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::Entry&>(
      ::_Entry_default_instance_);
}
inline const ::Entry& AppendEntryRequest::entry() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.entry)
  return _internal_entry();
}
inline void AppendEntryRequest::unsafe_arena_set_allocated_entry(
    ::Entry* entry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entry_);
  }
  entry_ = entry;
  if (entry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AppendEntryRequest.entry)
}
inline ::Entry* AppendEntryRequest::release_entry() {
  
  ::Entry* temp = entry_;
  entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Entry* AppendEntryRequest::unsafe_arena_release_entry() {
  // @@protoc_insertion_point(field_release:AppendEntryRequest.entry)
  
  ::Entry* temp = entry_;
  entry_ = nullptr;
  return temp;
}
inline ::Entry* AppendEntryRequest::_internal_mutable_entry() {
  
  if (entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::Entry>(GetArenaForAllocation());
    entry_ = p;
  }
  return entry_;
}
inline ::Entry* AppendEntryRequest::mutable_entry() {
  ::Entry* _msg = _internal_mutable_entry();
  // @@protoc_insertion_point(field_mutable:AppendEntryRequest.entry)
  return _msg;
}
inline void AppendEntryRequest::set_allocated_entry(::Entry* entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete entry_;
  }
  if (entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Entry>::GetOwningArena(entry);
    if (message_arena != submessage_arena) {
      entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    
  } else {
    
  }
  entry_ = entry;
  // @@protoc_insertion_point(field_set_allocated:AppendEntryRequest.entry)
}

// uint64 leader_commit = 6;
inline void AppendEntryRequest::clear_leader_commit() {
  leader_commit_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_leader_commit() const {
  return leader_commit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::leader_commit() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.leader_commit)
  return _internal_leader_commit();
}
inline void AppendEntryRequest::_internal_set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_commit_ = value;
}
inline void AppendEntryRequest::set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_commit(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.leader_commit)
}

// -------------------------------------------------------------------

// AppendEntryResponse

// uint64 term = 1;
inline void AppendEntryResponse::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryResponse::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryResponse::term() const {
  // @@protoc_insertion_point(field_get:AppendEntryResponse.term)
  return _internal_term();
}
inline void AppendEntryResponse::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void AppendEntryResponse::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:AppendEntryResponse.term)
}

// bool success = 2;
inline void AppendEntryResponse::clear_success() {
  success_ = false;
}
inline bool AppendEntryResponse::_internal_success() const {
  return success_;
}
inline bool AppendEntryResponse::success() const {
  // @@protoc_insertion_point(field_get:AppendEntryResponse.success)
  return _internal_success();
}
inline void AppendEntryResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void AppendEntryResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:AppendEntryResponse.success)
}

// -------------------------------------------------------------------

// RequestVoteRequest

// uint64 term = 1;
inline void RequestVoteRequest::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::term() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.term)
  return _internal_term();
}
inline void RequestVoteRequest::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void RequestVoteRequest::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.term)
}

// uint64 candidate_id = 2;
inline void RequestVoteRequest::clear_candidate_id() {
  candidate_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_candidate_id() const {
  return candidate_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::candidate_id() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.candidate_id)
  return _internal_candidate_id();
}
inline void RequestVoteRequest::_internal_set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  candidate_id_ = value;
}
inline void RequestVoteRequest::set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_candidate_id(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.candidate_id)
}

// uint64 last_log_entry = 3;
inline void RequestVoteRequest::clear_last_log_entry() {
  last_log_entry_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_last_log_entry() const {
  return last_log_entry_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::last_log_entry() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.last_log_entry)
  return _internal_last_log_entry();
}
inline void RequestVoteRequest::_internal_set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  last_log_entry_ = value;
}
inline void RequestVoteRequest::set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_log_entry(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.last_log_entry)
}

// uint64 last_log_term = 4;
inline void RequestVoteRequest::clear_last_log_term() {
  last_log_term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_last_log_term() const {
  return last_log_term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::last_log_term() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.last_log_term)
  return _internal_last_log_term();
}
inline void RequestVoteRequest::_internal_set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  last_log_term_ = value;
}
inline void RequestVoteRequest::set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_log_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.last_log_term)
}

// -------------------------------------------------------------------

// RequestVoteResponse

// uint64 term = 1;
inline void RequestVoteResponse::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteResponse::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteResponse::term() const {
  // @@protoc_insertion_point(field_get:RequestVoteResponse.term)
  return _internal_term();
}
inline void RequestVoteResponse::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void RequestVoteResponse::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteResponse.term)
}

// bool vote_granted = 2;
inline void RequestVoteResponse::clear_vote_granted() {
  vote_granted_ = false;
}
inline bool RequestVoteResponse::_internal_vote_granted() const {
  return vote_granted_;
}
inline bool RequestVoteResponse::vote_granted() const {
  // @@protoc_insertion_point(field_get:RequestVoteResponse.vote_granted)
  return _internal_vote_granted();
}
inline void RequestVoteResponse::_internal_set_vote_granted(bool value) {
  
  vote_granted_ = value;
}
inline void RequestVoteResponse::set_vote_granted(bool value) {
  _internal_set_vote_granted(value);
  // @@protoc_insertion_point(field_set:RequestVoteResponse.vote_granted)
}

// -------------------------------------------------------------------

// WorkerConnectRequest

// .WorkerStatus status = 1;
inline void WorkerConnectRequest::clear_status() {
  status_ = 0;
}
inline ::WorkerStatus WorkerConnectRequest::_internal_status() const {
  return static_cast< ::WorkerStatus >(status_);
}
inline ::WorkerStatus WorkerConnectRequest::status() const {
  // @@protoc_insertion_point(field_get:WorkerConnectRequest.status)
  return _internal_status();
}
inline void WorkerConnectRequest::_internal_set_status(::WorkerStatus value) {
  
  status_ = value;
}
inline void WorkerConnectRequest::set_status(::WorkerStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:WorkerConnectRequest.status)
}

// uint64 task_id = 2;
inline void WorkerConnectRequest::clear_task_id() {
  task_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectRequest::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectRequest::task_id() const {
  // @@protoc_insertion_point(field_get:WorkerConnectRequest.task_id)
  return _internal_task_id();
}
inline void WorkerConnectRequest::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  task_id_ = value;
}
inline void WorkerConnectRequest::set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:WorkerConnectRequest.task_id)
}

// .TaskResult task_result = 3;
inline bool WorkerConnectRequest::_internal_has_task_result() const {
  return this != internal_default_instance() && task_result_ != nullptr;
}
inline bool WorkerConnectRequest::has_task_result() const {
  return _internal_has_task_result();
}
inline void WorkerConnectRequest::clear_task_result() {
  if (GetArenaForAllocation() == nullptr && task_result_ != nullptr) {
    delete task_result_;
  }
  task_result_ = nullptr;
}
inline const ::TaskResult& WorkerConnectRequest::_internal_task_result() const {
  const ::TaskResult* p = task_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskResult&>(
      ::_TaskResult_default_instance_);
}
inline const ::TaskResult& WorkerConnectRequest::task_result() const {
  // @@protoc_insertion_point(field_get:WorkerConnectRequest.task_result)
  return _internal_task_result();
}
inline void WorkerConnectRequest::unsafe_arena_set_allocated_task_result(
    ::TaskResult* task_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_result_);
  }
  task_result_ = task_result;
  if (task_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerConnectRequest.task_result)
}
inline ::TaskResult* WorkerConnectRequest::release_task_result() {
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskResult* WorkerConnectRequest::unsafe_arena_release_task_result() {
  // @@protoc_insertion_point(field_release:WorkerConnectRequest.task_result)
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
  return temp;
}
inline ::TaskResult* WorkerConnectRequest::_internal_mutable_task_result() {
  
  if (task_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskResult>(GetArenaForAllocation());
    task_result_ = p;
  }
  return task_result_;
}
inline ::TaskResult* WorkerConnectRequest::mutable_task_result() {
  ::TaskResult* _msg = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:WorkerConnectRequest.task_result)
  return _msg;
}
inline void WorkerConnectRequest::set_allocated_task_result(::TaskResult* task_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_result_;
  }
  if (task_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskResult>::GetOwningArena(task_result);
    if (message_arena != submessage_arena) {
      task_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_result, submessage_arena);
    }
    
  } else {
    
  }
  task_result_ = task_result;
  // @@protoc_insertion_point(field_set_allocated:WorkerConnectRequest.task_result)
}

// -------------------------------------------------------------------

// WorkerConnectResponse

// .WorkerCommand command = 1;
inline void WorkerConnectResponse::clear_command() {
  command_ = 0;
}
inline ::WorkerCommand WorkerConnectResponse::_internal_command() const {
  return static_cast< ::WorkerCommand >(command_);
}
inline ::WorkerCommand WorkerConnectResponse::command() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.command)
  return _internal_command();
}
inline void WorkerConnectResponse::_internal_set_command(::WorkerCommand value) {
  
  command_ = value;
}
inline void WorkerConnectResponse::set_command(::WorkerCommand value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:WorkerConnectResponse.command)
}

// uint64 task_id = 2;
inline void WorkerConnectResponse::clear_task_id() {
  task_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectResponse::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectResponse::task_id() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.task_id)
  return _internal_task_id();
}
inline void WorkerConnectResponse::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  task_id_ = value;
}
inline void WorkerConnectResponse::set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:WorkerConnectResponse.task_id)
}

// uint64 leader_id = 3;
inline void WorkerConnectResponse::clear_leader_id() {
  leader_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectResponse::_internal_leader_id() const {
  return leader_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectResponse::leader_id() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.leader_id)
  return _internal_leader_id();
}
inline void WorkerConnectResponse::_internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_id_ = value;
}
inline void WorkerConnectResponse::set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_id(value);
  // @@protoc_insertion_point(field_set:WorkerConnectResponse.leader_id)
}

// .TaskData task_data = 4;
inline bool WorkerConnectResponse::_internal_has_task_data() const {
  return this != internal_default_instance() && task_data_ != nullptr;
}
inline bool WorkerConnectResponse::has_task_data() const {
  return _internal_has_task_data();
}
inline void WorkerConnectResponse::clear_task_data() {
  if (GetArenaForAllocation() == nullptr && task_data_ != nullptr) {
    delete task_data_;
  }
  task_data_ = nullptr;
}
inline const ::TaskData& WorkerConnectResponse::_internal_task_data() const {
  const ::TaskData* p = task_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskData&>(
      ::_TaskData_default_instance_);
}
inline const ::TaskData& WorkerConnectResponse::task_data() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.task_data)
  return _internal_task_data();
}
inline void WorkerConnectResponse::unsafe_arena_set_allocated_task_data(
    ::TaskData* task_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_data_);
  }
  task_data_ = task_data;
  if (task_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerConnectResponse.task_data)
}
inline ::TaskData* WorkerConnectResponse::release_task_data() {
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskData* WorkerConnectResponse::unsafe_arena_release_task_data() {
  // @@protoc_insertion_point(field_release:WorkerConnectResponse.task_data)
  
  ::TaskData* temp = task_data_;
  task_data_ = nullptr;
  return temp;
}
inline ::TaskData* WorkerConnectResponse::_internal_mutable_task_data() {
  
  if (task_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskData>(GetArenaForAllocation());
    task_data_ = p;
  }
  return task_data_;
}
inline ::TaskData* WorkerConnectResponse::mutable_task_data() {
  ::TaskData* _msg = _internal_mutable_task_data();
  // @@protoc_insertion_point(field_mutable:WorkerConnectResponse.task_data)
  return _msg;
}
inline void WorkerConnectResponse::set_allocated_task_data(::TaskData* task_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_data_;
  }
  if (task_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskData>::GetOwningArena(task_data);
    if (message_arena != submessage_arena) {
      task_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_data, submessage_arena);
    }
    
  } else {
    
  }
  task_data_ = task_data;
  // @@protoc_insertion_point(field_set_allocated:WorkerConnectResponse.task_data)
}

// .TaskResult task_result = 5;
inline bool WorkerConnectResponse::_internal_has_task_result() const {
  return this != internal_default_instance() && task_result_ != nullptr;
}
inline bool WorkerConnectResponse::has_task_result() const {
  return _internal_has_task_result();
}
inline void WorkerConnectResponse::clear_task_result() {
  if (GetArenaForAllocation() == nullptr && task_result_ != nullptr) {
    delete task_result_;
  }
  task_result_ = nullptr;
}
inline const ::TaskResult& WorkerConnectResponse::_internal_task_result() const {
  const ::TaskResult* p = task_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskResult&>(
      ::_TaskResult_default_instance_);
}
inline const ::TaskResult& WorkerConnectResponse::task_result() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.task_result)
  return _internal_task_result();
}
inline void WorkerConnectResponse::unsafe_arena_set_allocated_task_result(
    ::TaskResult* task_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_result_);
  }
  task_result_ = task_result;
  if (task_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerConnectResponse.task_result)
}
inline ::TaskResult* WorkerConnectResponse::release_task_result() {
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskResult* WorkerConnectResponse::unsafe_arena_release_task_result() {
  // @@protoc_insertion_point(field_release:WorkerConnectResponse.task_result)
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
  return temp;
}
inline ::TaskResult* WorkerConnectResponse::_internal_mutable_task_result() {
  
  if (task_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskResult>(GetArenaForAllocation());
    task_result_ = p;
  }
  return task_result_;
}
inline ::TaskResult* WorkerConnectResponse::mutable_task_result() {
  ::TaskResult* _msg = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:WorkerConnectResponse.task_result)
  return _msg;
}
inline void WorkerConnectResponse::set_allocated_task_result(::TaskResult* task_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_result_;
  }
  if (task_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskResult>::GetOwningArena(task_result);
    if (message_arena != submessage_arena) {
      task_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_result, submessage_arena);
    }
    
  } else {
    
  }
  task_result_ = task_result;
  // @@protoc_insertion_point(field_set_allocated:WorkerConnectResponse.task_result)
}

// -------------------------------------------------------------------

// AssignTaskRequest

// uint64 task_id = 1;
inline void AssignTaskRequest::clear_task_id() {
  task_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AssignTaskRequest::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AssignTaskRequest::task_id() const {
  // @@protoc_insertion_point(field_get:AssignTaskRequest.task_id)
  return _internal_task_id();
}
inline void AssignTaskRequest::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  task_id_ = value;
}
inline void AssignTaskRequest::set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:AssignTaskRequest.task_id)
}

// -------------------------------------------------------------------

// AssignTaskResponse

// bool success = 1;
inline void AssignTaskResponse::clear_success() {
  success_ = false;
}
inline bool AssignTaskResponse::_internal_success() const {
  return success_;
}
inline bool AssignTaskResponse::success() const {
  // @@protoc_insertion_point(field_get:AssignTaskResponse.success)
  return _internal_success();
}
inline void AssignTaskResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void AssignTaskResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:AssignTaskResponse.success)
}

// uint64 worker_id = 2;
inline void AssignTaskResponse::clear_worker_id() {
  worker_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AssignTaskResponse::_internal_worker_id() const {
  return worker_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AssignTaskResponse::worker_id() const {
  // @@protoc_insertion_point(field_get:AssignTaskResponse.worker_id)
  return _internal_worker_id();
}
inline void AssignTaskResponse::_internal_set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  worker_id_ = value;
}
inline void AssignTaskResponse::set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_worker_id(value);
  // @@protoc_insertion_point(field_set:AssignTaskResponse.worker_id)
}

// -------------------------------------------------------------------

// SendTaskRequest

// .Task task = 1;
inline bool SendTaskRequest::_internal_has_task() const {
  return this != internal_default_instance() && task_ != nullptr;
}
inline bool SendTaskRequest::has_task() const {
  return _internal_has_task();
}
inline void SendTaskRequest::clear_task() {
  if (GetArenaForAllocation() == nullptr && task_ != nullptr) {
    delete task_;
  }
  task_ = nullptr;
}
inline const ::Task& SendTaskRequest::_internal_task() const {
  const ::Task* p = task_;
  return p != nullptr ? *p : reinterpret_cast<const ::Task&>(
      ::_Task_default_instance_);
}
inline const ::Task& SendTaskRequest::task() const {
  // @@protoc_insertion_point(field_get:SendTaskRequest.task)
  return _internal_task();
}
inline void SendTaskRequest::unsafe_arena_set_allocated_task(
    ::Task* task) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_);
  }
  task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SendTaskRequest.task)
}
inline ::Task* SendTaskRequest::release_task() {
  
  ::Task* temp = task_;
  task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Task* SendTaskRequest::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:SendTaskRequest.task)
  
  ::Task* temp = task_;
  task_ = nullptr;
  return temp;
}
inline ::Task* SendTaskRequest::_internal_mutable_task() {
  
  if (task_ == nullptr) {
    auto* p = CreateMaybeMessage<::Task>(GetArenaForAllocation());
    task_ = p;
  }
  return task_;
}
inline ::Task* SendTaskRequest::mutable_task() {
  ::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:SendTaskRequest.task)
  return _msg;
}
inline void SendTaskRequest::set_allocated_task(::Task* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_;
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Task>::GetOwningArena(task);
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:SendTaskRequest.task)
}

// -------------------------------------------------------------------

// SendTaskResponse

// bool success = 1;
inline void SendTaskResponse::clear_success() {
  success_ = false;
}
inline bool SendTaskResponse::_internal_success() const {
  return success_;
}
inline bool SendTaskResponse::success() const {
  // @@protoc_insertion_point(field_get:SendTaskResponse.success)
  return _internal_success();
}
inline void SendTaskResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void SendTaskResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:SendTaskResponse.success)
}

// -------------------------------------------------------------------

// GetWorkerResultRequest

// uint64 worker_id = 1;
inline void GetWorkerResultRequest::clear_worker_id() {
  worker_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetWorkerResultRequest::_internal_worker_id() const {
  return worker_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetWorkerResultRequest::worker_id() const {
  // @@protoc_insertion_point(field_get:GetWorkerResultRequest.worker_id)
  return _internal_worker_id();
}
inline void GetWorkerResultRequest::_internal_set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  worker_id_ = value;
}
inline void GetWorkerResultRequest::set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_worker_id(value);
  // @@protoc_insertion_point(field_set:GetWorkerResultRequest.worker_id)
}

// uint64 task_id = 2;
inline void GetWorkerResultRequest::clear_task_id() {
  task_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetWorkerResultRequest::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetWorkerResultRequest::task_id() const {
  // @@protoc_insertion_point(field_get:GetWorkerResultRequest.task_id)
  return _internal_task_id();
}
inline void GetWorkerResultRequest::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  task_id_ = value;
}
inline void GetWorkerResultRequest::set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:GetWorkerResultRequest.task_id)
}

// -------------------------------------------------------------------

// GetWorkerResultResponse

// .TaskResult task_result = 2;
inline bool GetWorkerResultResponse::_internal_has_task_result() const {
  return this != internal_default_instance() && task_result_ != nullptr;
}
inline bool GetWorkerResultResponse::has_task_result() const {
  return _internal_has_task_result();
}
inline void GetWorkerResultResponse::clear_task_result() {
  if (GetArenaForAllocation() == nullptr && task_result_ != nullptr) {
    delete task_result_;
  }
  task_result_ = nullptr;
}
inline const ::TaskResult& GetWorkerResultResponse::_internal_task_result() const {
  const ::TaskResult* p = task_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskResult&>(
      ::_TaskResult_default_instance_);
}
inline const ::TaskResult& GetWorkerResultResponse::task_result() const {
  // @@protoc_insertion_point(field_get:GetWorkerResultResponse.task_result)
  return _internal_task_result();
}
inline void GetWorkerResultResponse::unsafe_arena_set_allocated_task_result(
    ::TaskResult* task_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_result_);
  }
  task_result_ = task_result;
  if (task_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GetWorkerResultResponse.task_result)
}
inline ::TaskResult* GetWorkerResultResponse::release_task_result() {
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskResult* GetWorkerResultResponse::unsafe_arena_release_task_result() {
  // @@protoc_insertion_point(field_release:GetWorkerResultResponse.task_result)
  
  ::TaskResult* temp = task_result_;
  task_result_ = nullptr;
  return temp;
}
inline ::TaskResult* GetWorkerResultResponse::_internal_mutable_task_result() {
  
  if (task_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskResult>(GetArenaForAllocation());
    task_result_ = p;
  }
  return task_result_;
}
inline ::TaskResult* GetWorkerResultResponse::mutable_task_result() {
  ::TaskResult* _msg = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:GetWorkerResultResponse.task_result)
  return _msg;
}
inline void GetWorkerResultResponse::set_allocated_task_result(::TaskResult* task_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_result_;
  }
  if (task_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskResult>::GetOwningArena(task_result);
    if (message_arena != submessage_arena) {
      task_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_result, submessage_arena);
    }
    
  } else {
    
  }
  task_result_ = task_result;
  // @@protoc_insertion_point(field_set_allocated:GetWorkerResultResponse.task_result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Command_CommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Command_CommandType>() {
  return ::Command_CommandType_descriptor();
}
template <> struct is_proto_enum< ::UserStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UserStatus>() {
  return ::UserStatus_descriptor();
}
template <> struct is_proto_enum< ::UserCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UserCommand>() {
  return ::UserCommand_descriptor();
}
template <> struct is_proto_enum< ::TaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TaskStatus>() {
  return ::TaskStatus_descriptor();
}
template <> struct is_proto_enum< ::WorkerStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WorkerStatus>() {
  return ::WorkerStatus_descriptor();
}
template <> struct is_proto_enum< ::WorkerCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WorkerCommand>() {
  return ::WorkerCommand_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_abeille_2eproto
