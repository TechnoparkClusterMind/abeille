// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: abeille.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_abeille_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_abeille_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_abeille_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_abeille_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_abeille_2eproto;
class AddRequest;
struct AddRequestDefaultTypeInternal;
extern AddRequestDefaultTypeInternal _AddRequest_default_instance_;
class AppendEntryRequest;
struct AppendEntryRequestDefaultTypeInternal;
extern AppendEntryRequestDefaultTypeInternal _AppendEntryRequest_default_instance_;
class AppendEntryResponse;
struct AppendEntryResponseDefaultTypeInternal;
extern AppendEntryResponseDefaultTypeInternal _AppendEntryResponse_default_instance_;
class ClientRPCConfig;
struct ClientRPCConfigDefaultTypeInternal;
extern ClientRPCConfigDefaultTypeInternal _ClientRPCConfig_default_instance_;
class Entry;
struct EntryDefaultTypeInternal;
extern EntryDefaultTypeInternal _Entry_default_instance_;
class MoveRequest;
struct MoveRequestDefaultTypeInternal;
extern MoveRequestDefaultTypeInternal _MoveRequest_default_instance_;
class RaftConfig;
struct RaftConfigDefaultTypeInternal;
extern RaftConfigDefaultTypeInternal _RaftConfig_default_instance_;
class RequestVoteRequest;
struct RequestVoteRequestDefaultTypeInternal;
extern RequestVoteRequestDefaultTypeInternal _RequestVoteRequest_default_instance_;
class RequestVoteResponse;
struct RequestVoteResponseDefaultTypeInternal;
extern RequestVoteResponseDefaultTypeInternal _RequestVoteResponse_default_instance_;
class TaskID;
struct TaskIDDefaultTypeInternal;
extern TaskIDDefaultTypeInternal _TaskID_default_instance_;
class TaskState;
struct TaskStateDefaultTypeInternal;
extern TaskStateDefaultTypeInternal _TaskState_default_instance_;
class TaskWrapper;
struct TaskWrapperDefaultTypeInternal;
extern TaskWrapperDefaultTypeInternal _TaskWrapper_default_instance_;
class UserConnectRequest;
struct UserConnectRequestDefaultTypeInternal;
extern UserConnectRequestDefaultTypeInternal _UserConnectRequest_default_instance_;
class UserConnectResponse;
struct UserConnectResponseDefaultTypeInternal;
extern UserConnectResponseDefaultTypeInternal _UserConnectResponse_default_instance_;
class WorkerConnectRequest;
struct WorkerConnectRequestDefaultTypeInternal;
extern WorkerConnectRequestDefaultTypeInternal _WorkerConnectRequest_default_instance_;
class WorkerConnectResponse;
struct WorkerConnectResponseDefaultTypeInternal;
extern WorkerConnectResponseDefaultTypeInternal _WorkerConnectResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AddRequest* Arena::CreateMaybeMessage<::AddRequest>(Arena*);
template<> ::AppendEntryRequest* Arena::CreateMaybeMessage<::AppendEntryRequest>(Arena*);
template<> ::AppendEntryResponse* Arena::CreateMaybeMessage<::AppendEntryResponse>(Arena*);
template<> ::ClientRPCConfig* Arena::CreateMaybeMessage<::ClientRPCConfig>(Arena*);
template<> ::Entry* Arena::CreateMaybeMessage<::Entry>(Arena*);
template<> ::MoveRequest* Arena::CreateMaybeMessage<::MoveRequest>(Arena*);
template<> ::RaftConfig* Arena::CreateMaybeMessage<::RaftConfig>(Arena*);
template<> ::RequestVoteRequest* Arena::CreateMaybeMessage<::RequestVoteRequest>(Arena*);
template<> ::RequestVoteResponse* Arena::CreateMaybeMessage<::RequestVoteResponse>(Arena*);
template<> ::TaskID* Arena::CreateMaybeMessage<::TaskID>(Arena*);
template<> ::TaskState* Arena::CreateMaybeMessage<::TaskState>(Arena*);
template<> ::TaskWrapper* Arena::CreateMaybeMessage<::TaskWrapper>(Arena*);
template<> ::UserConnectRequest* Arena::CreateMaybeMessage<::UserConnectRequest>(Arena*);
template<> ::UserConnectResponse* Arena::CreateMaybeMessage<::UserConnectResponse>(Arena*);
template<> ::WorkerConnectRequest* Arena::CreateMaybeMessage<::WorkerConnectRequest>(Arena*);
template<> ::WorkerConnectResponse* Arena::CreateMaybeMessage<::WorkerConnectResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum TaskStatus : int {
  TASK_STATUS_ASSIGNED = 0,
  TASK_STATUS_COMPLETED = 1,
  TaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskStatus_IsValid(int value);
constexpr TaskStatus TaskStatus_MIN = TASK_STATUS_ASSIGNED;
constexpr TaskStatus TaskStatus_MAX = TASK_STATUS_COMPLETED;
constexpr int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskStatus_descriptor();
template<typename T>
inline const std::string& TaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskStatus_descriptor(), enum_t_value);
}
inline bool TaskStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskStatus>(
    TaskStatus_descriptor(), name, value);
}
enum RaftCommand : int {
  RAFT_COMMAND_ADD = 0,
  RAFT_COMMAND_MOVE = 1,
  RaftCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RaftCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RaftCommand_IsValid(int value);
constexpr RaftCommand RaftCommand_MIN = RAFT_COMMAND_ADD;
constexpr RaftCommand RaftCommand_MAX = RAFT_COMMAND_MOVE;
constexpr int RaftCommand_ARRAYSIZE = RaftCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RaftCommand_descriptor();
template<typename T>
inline const std::string& RaftCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RaftCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RaftCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RaftCommand_descriptor(), enum_t_value);
}
inline bool RaftCommand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RaftCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RaftCommand>(
    RaftCommand_descriptor(), name, value);
}
enum UserStatus : int {
  USER_STATUS_DOWN = 0,
  USER_STATUS_IDLE = 1,
  USER_STATUS_UPLOAD_DATA = 2,
  USER_STATUS_GET_RESULT = 3,
  UserStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserStatus_IsValid(int value);
constexpr UserStatus UserStatus_MIN = USER_STATUS_DOWN;
constexpr UserStatus UserStatus_MAX = USER_STATUS_GET_RESULT;
constexpr int UserStatus_ARRAYSIZE = UserStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserStatus_descriptor();
template<typename T>
inline const std::string& UserStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserStatus_descriptor(), enum_t_value);
}
inline bool UserStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserStatus>(
    UserStatus_descriptor(), name, value);
}
enum UserCommand : int {
  USER_COMMAND_NONE = 0,
  USER_COMMAND_REDIRECT = 1,
  USER_COMMAND_ASSIGN = 2,
  USER_COMMAND_RESULT = 3,
  UserCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserCommand_IsValid(int value);
constexpr UserCommand UserCommand_MIN = USER_COMMAND_NONE;
constexpr UserCommand UserCommand_MAX = USER_COMMAND_RESULT;
constexpr int UserCommand_ARRAYSIZE = UserCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserCommand_descriptor();
template<typename T>
inline const std::string& UserCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserCommand_descriptor(), enum_t_value);
}
inline bool UserCommand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserCommand>(
    UserCommand_descriptor(), name, value);
}
enum WorkerStatus : int {
  WORKER_STATUS_DOWN = 0,
  WORKER_STATUS_IDLE = 1,
  WORKER_STATUS_BUSY = 2,
  WORKER_STATUS_COMPLETED = 3,
  WorkerStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkerStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkerStatus_IsValid(int value);
constexpr WorkerStatus WorkerStatus_MIN = WORKER_STATUS_DOWN;
constexpr WorkerStatus WorkerStatus_MAX = WORKER_STATUS_COMPLETED;
constexpr int WorkerStatus_ARRAYSIZE = WorkerStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkerStatus_descriptor();
template<typename T>
inline const std::string& WorkerStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkerStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkerStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkerStatus_descriptor(), enum_t_value);
}
inline bool WorkerStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkerStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkerStatus>(
    WorkerStatus_descriptor(), name, value);
}
enum WorkerCommand : int {
  WORKER_COMMAND_NONE = 0,
  WORKER_COMMAND_ASSIGN = 1,
  WORKER_COMMAND_PROCESS = 2,
  WORKER_COMMAND_REDIRECT = 3,
  WorkerCommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkerCommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkerCommand_IsValid(int value);
constexpr WorkerCommand WorkerCommand_MIN = WORKER_COMMAND_NONE;
constexpr WorkerCommand WorkerCommand_MAX = WORKER_COMMAND_REDIRECT;
constexpr int WorkerCommand_ARRAYSIZE = WorkerCommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkerCommand_descriptor();
template<typename T>
inline const std::string& WorkerCommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkerCommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkerCommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkerCommand_descriptor(), enum_t_value);
}
inline bool WorkerCommand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkerCommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkerCommand>(
    WorkerCommand_descriptor(), name, value);
}
// ===================================================================

class TaskID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskID) */ {
 public:
  inline TaskID() : TaskID(nullptr) {}
  ~TaskID() override;
  explicit constexpr TaskID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskID(const TaskID& from);
  TaskID(TaskID&& from) noexcept
    : TaskID() {
    *this = ::std::move(from);
  }

  inline TaskID& operator=(const TaskID& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskID& operator=(TaskID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskID& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskID* internal_default_instance() {
    return reinterpret_cast<const TaskID*>(
               &_TaskID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TaskID& a, TaskID& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskID* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskID* New() const final {
    return new TaskID();
  }

  TaskID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskID& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskID";
  }
  protected:
  explicit TaskID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kClientIdFieldNumber = 2,
  };
  // uint64 number = 1;
  void clear_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 number() const;
  void set_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_number() const;
  void _internal_set_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 client_id = 2;
  void clear_client_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 client_id() const;
  void set_client_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_client_id() const;
  void _internal_set_client_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:TaskID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 number_;
  ::PROTOBUF_NAMESPACE_ID::uint64 client_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class TaskState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskState) */ {
 public:
  inline TaskState() : TaskState(nullptr) {}
  ~TaskState() override;
  explicit constexpr TaskState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskState(const TaskState& from);
  TaskState(TaskState&& from) noexcept
    : TaskState() {
    *this = ::std::move(from);
  }

  inline TaskState& operator=(const TaskState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskState& operator=(TaskState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskState& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskState* internal_default_instance() {
    return reinterpret_cast<const TaskState*>(
               &_TaskState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TaskState& a, TaskState& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskState* New() const final {
    return new TaskState();
  }

  TaskState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskState";
  }
  protected:
  explicit TaskState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskResultFieldNumber = 2,
    kTaskIdFieldNumber = 1,
  };
  // bytes task_result = 2;
  void clear_task_result();
  const std::string& task_result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_result();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_result();
  void set_allocated_task_result(std::string* task_result);
  private:
  const std::string& _internal_task_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_result(const std::string& value);
  std::string* _internal_mutable_task_result();
  public:

  // .TaskID task_id = 1;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  const ::TaskID& task_id() const;
  PROTOBUF_MUST_USE_RESULT ::TaskID* release_task_id();
  ::TaskID* mutable_task_id();
  void set_allocated_task_id(::TaskID* task_id);
  private:
  const ::TaskID& _internal_task_id() const;
  ::TaskID* _internal_mutable_task_id();
  public:
  void unsafe_arena_set_allocated_task_id(
      ::TaskID* task_id);
  ::TaskID* unsafe_arena_release_task_id();

  // @@protoc_insertion_point(class_scope:TaskState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_result_;
  ::TaskID* task_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class TaskWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskWrapper) */ {
 public:
  inline TaskWrapper() : TaskWrapper(nullptr) {}
  ~TaskWrapper() override;
  explicit constexpr TaskWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskWrapper(const TaskWrapper& from);
  TaskWrapper(TaskWrapper&& from) noexcept
    : TaskWrapper() {
    *this = ::std::move(from);
  }

  inline TaskWrapper& operator=(const TaskWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskWrapper& operator=(TaskWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskWrapper* internal_default_instance() {
    return reinterpret_cast<const TaskWrapper*>(
               &_TaskWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TaskWrapper& a, TaskWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskWrapper* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskWrapper* New() const final {
    return new TaskWrapper();
  }

  TaskWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskWrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskWrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskWrapper& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskWrapper* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskWrapper";
  }
  protected:
  explicit TaskWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskDataFieldNumber = 3,
    kTaskResultFieldNumber = 4,
    kTaskIdFieldNumber = 1,
    kWorkerIdFieldNumber = 2,
  };
  // bytes task_data = 3;
  void clear_task_data();
  const std::string& task_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_data();
  void set_allocated_task_data(std::string* task_data);
  private:
  const std::string& _internal_task_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_data(const std::string& value);
  std::string* _internal_mutable_task_data();
  public:

  // bytes task_result = 4;
  void clear_task_result();
  const std::string& task_result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_result();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_result();
  void set_allocated_task_result(std::string* task_result);
  private:
  const std::string& _internal_task_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_result(const std::string& value);
  std::string* _internal_mutable_task_result();
  public:

  // .TaskID task_id = 1;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  const ::TaskID& task_id() const;
  PROTOBUF_MUST_USE_RESULT ::TaskID* release_task_id();
  ::TaskID* mutable_task_id();
  void set_allocated_task_id(::TaskID* task_id);
  private:
  const ::TaskID& _internal_task_id() const;
  ::TaskID* _internal_mutable_task_id();
  public:
  void unsafe_arena_set_allocated_task_id(
      ::TaskID* task_id);
  ::TaskID* unsafe_arena_release_task_id();

  // uint64 worker_id = 2;
  void clear_worker_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 worker_id() const;
  void set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_worker_id() const;
  void _internal_set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:TaskWrapper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_result_;
  ::TaskID* task_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 worker_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class AddRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AddRequest) */ {
 public:
  inline AddRequest() : AddRequest(nullptr) {}
  ~AddRequest() override;
  explicit constexpr AddRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddRequest(const AddRequest& from);
  AddRequest(AddRequest&& from) noexcept
    : AddRequest() {
    *this = ::std::move(from);
  }

  inline AddRequest& operator=(const AddRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddRequest& operator=(AddRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddRequest* internal_default_instance() {
    return reinterpret_cast<const AddRequest*>(
               &_AddRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AddRequest& a, AddRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddRequest* New() const final {
    return new AddRequest();
  }

  AddRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AddRequest";
  }
  protected:
  explicit AddRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
  };
  // .TaskStatus to = 1;
  void clear_to();
  ::TaskStatus to() const;
  void set_to(::TaskStatus value);
  private:
  ::TaskStatus _internal_to() const;
  void _internal_set_to(::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:AddRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int to_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class MoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MoveRequest) */ {
 public:
  inline MoveRequest() : MoveRequest(nullptr) {}
  ~MoveRequest() override;
  explicit constexpr MoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveRequest(const MoveRequest& from);
  MoveRequest(MoveRequest&& from) noexcept
    : MoveRequest() {
    *this = ::std::move(from);
  }

  inline MoveRequest& operator=(const MoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveRequest& operator=(MoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveRequest* internal_default_instance() {
    return reinterpret_cast<const MoveRequest*>(
               &_MoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MoveRequest& a, MoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveRequest* New() const final {
    return new MoveRequest();
  }

  MoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MoveRequest";
  }
  protected:
  explicit MoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
    kFromFieldNumber = 2,
  };
  // .TaskStatus to = 1;
  void clear_to();
  ::TaskStatus to() const;
  void set_to(::TaskStatus value);
  private:
  ::TaskStatus _internal_to() const;
  void _internal_set_to(::TaskStatus value);
  public:

  // .TaskStatus from = 2;
  void clear_from();
  ::TaskStatus from() const;
  void set_from(::TaskStatus value);
  private:
  ::TaskStatus _internal_from() const;
  void _internal_set_from(::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:MoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int to_;
  int from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Entry) */ {
 public:
  inline Entry() : Entry(nullptr) {}
  ~Entry() override;
  explicit constexpr Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entry(const Entry& from);
  Entry(Entry&& from) noexcept
    : Entry() {
    *this = ::std::move(from);
  }

  inline Entry& operator=(const Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entry& operator=(Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entry* internal_default_instance() {
    return reinterpret_cast<const Entry*>(
               &_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Entry& a, Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(Entry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Entry* New() const final {
    return new Entry();
  }

  Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Entry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Entry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Entry";
  }
  protected:
  explicit Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskWrapperFieldNumber = 3,
    kAddRequestFieldNumber = 4,
    kMoveRequestFieldNumber = 5,
    kTermFieldNumber = 2,
    kCommandFieldNumber = 1,
  };
  // .TaskWrapper task_wrapper = 3;
  bool has_task_wrapper() const;
  private:
  bool _internal_has_task_wrapper() const;
  public:
  void clear_task_wrapper();
  const ::TaskWrapper& task_wrapper() const;
  PROTOBUF_MUST_USE_RESULT ::TaskWrapper* release_task_wrapper();
  ::TaskWrapper* mutable_task_wrapper();
  void set_allocated_task_wrapper(::TaskWrapper* task_wrapper);
  private:
  const ::TaskWrapper& _internal_task_wrapper() const;
  ::TaskWrapper* _internal_mutable_task_wrapper();
  public:
  void unsafe_arena_set_allocated_task_wrapper(
      ::TaskWrapper* task_wrapper);
  ::TaskWrapper* unsafe_arena_release_task_wrapper();

  // .AddRequest add_request = 4;
  bool has_add_request() const;
  private:
  bool _internal_has_add_request() const;
  public:
  void clear_add_request();
  const ::AddRequest& add_request() const;
  PROTOBUF_MUST_USE_RESULT ::AddRequest* release_add_request();
  ::AddRequest* mutable_add_request();
  void set_allocated_add_request(::AddRequest* add_request);
  private:
  const ::AddRequest& _internal_add_request() const;
  ::AddRequest* _internal_mutable_add_request();
  public:
  void unsafe_arena_set_allocated_add_request(
      ::AddRequest* add_request);
  ::AddRequest* unsafe_arena_release_add_request();

  // .MoveRequest move_request = 5;
  bool has_move_request() const;
  private:
  bool _internal_has_move_request() const;
  public:
  void clear_move_request();
  const ::MoveRequest& move_request() const;
  PROTOBUF_MUST_USE_RESULT ::MoveRequest* release_move_request();
  ::MoveRequest* mutable_move_request();
  void set_allocated_move_request(::MoveRequest* move_request);
  private:
  const ::MoveRequest& _internal_move_request() const;
  ::MoveRequest* _internal_mutable_move_request();
  public:
  void unsafe_arena_set_allocated_move_request(
      ::MoveRequest* move_request);
  ::MoveRequest* unsafe_arena_release_move_request();

  // uint64 term = 2;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .RaftCommand command = 1;
  void clear_command();
  ::RaftCommand command() const;
  void set_command(::RaftCommand value);
  private:
  ::RaftCommand _internal_command() const;
  void _internal_set_command(::RaftCommand value);
  public:

  // @@protoc_insertion_point(class_scope:Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskWrapper* task_wrapper_;
  ::AddRequest* add_request_;
  ::MoveRequest* move_request_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class AppendEntryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AppendEntryRequest) */ {
 public:
  inline AppendEntryRequest() : AppendEntryRequest(nullptr) {}
  ~AppendEntryRequest() override;
  explicit constexpr AppendEntryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntryRequest(const AppendEntryRequest& from);
  AppendEntryRequest(AppendEntryRequest&& from) noexcept
    : AppendEntryRequest() {
    *this = ::std::move(from);
  }

  inline AppendEntryRequest& operator=(const AppendEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntryRequest& operator=(AppendEntryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntryRequest* internal_default_instance() {
    return reinterpret_cast<const AppendEntryRequest*>(
               &_AppendEntryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AppendEntryRequest& a, AppendEntryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppendEntryRequest* New() const final {
    return new AppendEntryRequest();
  }

  AppendEntryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppendEntryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AppendEntryRequest";
  }
  protected:
  explicit AppendEntryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 5,
    kTermFieldNumber = 1,
    kLeaderIdFieldNumber = 2,
    kPrevLogIndexFieldNumber = 3,
    kPrevLogTermFieldNumber = 4,
    kLeaderCommitFieldNumber = 6,
  };
  // .Entry entry = 5;
  bool has_entry() const;
  private:
  bool _internal_has_entry() const;
  public:
  void clear_entry();
  const ::Entry& entry() const;
  PROTOBUF_MUST_USE_RESULT ::Entry* release_entry();
  ::Entry* mutable_entry();
  void set_allocated_entry(::Entry* entry);
  private:
  const ::Entry& _internal_entry() const;
  ::Entry* _internal_mutable_entry();
  public:
  void unsafe_arena_set_allocated_entry(
      ::Entry* entry);
  ::Entry* unsafe_arena_release_entry();

  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 leader_id = 2;
  void clear_leader_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id() const;
  void set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_id() const;
  void _internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 prev_log_index = 3;
  void clear_prev_log_index();
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_index() const;
  void set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_prev_log_index() const;
  void _internal_set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 prev_log_term = 4;
  void clear_prev_log_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_term() const;
  void set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_prev_log_term() const;
  void _internal_set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 leader_commit = 6;
  void clear_leader_commit();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_commit() const;
  void set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_commit() const;
  void _internal_set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:AppendEntryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Entry* entry_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_index_;
  ::PROTOBUF_NAMESPACE_ID::uint64 prev_log_term_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_commit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class AppendEntryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AppendEntryResponse) */ {
 public:
  inline AppendEntryResponse() : AppendEntryResponse(nullptr) {}
  ~AppendEntryResponse() override;
  explicit constexpr AppendEntryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntryResponse(const AppendEntryResponse& from);
  AppendEntryResponse(AppendEntryResponse&& from) noexcept
    : AppendEntryResponse() {
    *this = ::std::move(from);
  }

  inline AppendEntryResponse& operator=(const AppendEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntryResponse& operator=(AppendEntryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntryResponse* internal_default_instance() {
    return reinterpret_cast<const AppendEntryResponse*>(
               &_AppendEntryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AppendEntryResponse& a, AppendEntryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppendEntryResponse* New() const final {
    return new AppendEntryResponse();
  }

  AppendEntryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppendEntryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AppendEntryResponse";
  }
  protected:
  explicit AppendEntryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:AppendEntryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RequestVoteRequest) */ {
 public:
  inline RequestVoteRequest() : RequestVoteRequest(nullptr) {}
  ~RequestVoteRequest() override;
  explicit constexpr RequestVoteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteRequest(const RequestVoteRequest& from);
  RequestVoteRequest(RequestVoteRequest&& from) noexcept
    : RequestVoteRequest() {
    *this = ::std::move(from);
  }

  inline RequestVoteRequest& operator=(const RequestVoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteRequest& operator=(RequestVoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteRequest* internal_default_instance() {
    return reinterpret_cast<const RequestVoteRequest*>(
               &_RequestVoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RequestVoteRequest& a, RequestVoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteRequest* New() const final {
    return new RequestVoteRequest();
  }

  RequestVoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestVoteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RequestVoteRequest";
  }
  protected:
  explicit RequestVoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kCandidateIdFieldNumber = 2,
    kLastLogEntryFieldNumber = 3,
    kLastLogTermFieldNumber = 4,
  };
  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 candidate_id = 2;
  void clear_candidate_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 candidate_id() const;
  void set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_candidate_id() const;
  void _internal_set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 last_log_entry = 3;
  void clear_last_log_entry();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_entry() const;
  void set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_log_entry() const;
  void _internal_set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 last_log_term = 4;
  void clear_last_log_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_term() const;
  void set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_log_term() const;
  void _internal_set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:RequestVoteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  ::PROTOBUF_NAMESPACE_ID::uint64 candidate_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_entry_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_log_term_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RequestVoteResponse) */ {
 public:
  inline RequestVoteResponse() : RequestVoteResponse(nullptr) {}
  ~RequestVoteResponse() override;
  explicit constexpr RequestVoteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteResponse(const RequestVoteResponse& from);
  RequestVoteResponse(RequestVoteResponse&& from) noexcept
    : RequestVoteResponse() {
    *this = ::std::move(from);
  }

  inline RequestVoteResponse& operator=(const RequestVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteResponse& operator=(RequestVoteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteResponse* internal_default_instance() {
    return reinterpret_cast<const RequestVoteResponse*>(
               &_RequestVoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RequestVoteResponse& a, RequestVoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteResponse* New() const final {
    return new RequestVoteResponse();
  }

  RequestVoteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestVoteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RequestVoteResponse";
  }
  protected:
  explicit RequestVoteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kVoteGrantedFieldNumber = 2,
  };
  // uint64 term = 1;
  void clear_term();
  ::PROTOBUF_NAMESPACE_ID::uint64 term() const;
  void set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_term() const;
  void _internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool vote_granted = 2;
  void clear_vote_granted();
  bool vote_granted() const;
  void set_vote_granted(bool value);
  private:
  bool _internal_vote_granted() const;
  void _internal_set_vote_granted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RequestVoteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 term_;
  bool vote_granted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class UserConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserConnectRequest) */ {
 public:
  inline UserConnectRequest() : UserConnectRequest(nullptr) {}
  ~UserConnectRequest() override;
  explicit constexpr UserConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserConnectRequest(const UserConnectRequest& from);
  UserConnectRequest(UserConnectRequest&& from) noexcept
    : UserConnectRequest() {
    *this = ::std::move(from);
  }

  inline UserConnectRequest& operator=(const UserConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserConnectRequest& operator=(UserConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserConnectRequest* internal_default_instance() {
    return reinterpret_cast<const UserConnectRequest*>(
               &_UserConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UserConnectRequest& a, UserConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserConnectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserConnectRequest* New() const final {
    return new UserConnectRequest();
  }

  UserConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserConnectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserConnectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserConnectRequest";
  }
  protected:
  explicit UserConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskDataFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // bytes task_data = 2;
  void clear_task_data();
  const std::string& task_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_data();
  void set_allocated_task_data(std::string* task_data);
  private:
  const std::string& _internal_task_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_data(const std::string& value);
  std::string* _internal_mutable_task_data();
  public:

  // .UserStatus status = 1;
  void clear_status();
  ::UserStatus status() const;
  void set_status(::UserStatus value);
  private:
  ::UserStatus _internal_status() const;
  void _internal_set_status(::UserStatus value);
  public:

  // @@protoc_insertion_point(class_scope:UserConnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_data_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class UserConnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserConnectResponse) */ {
 public:
  inline UserConnectResponse() : UserConnectResponse(nullptr) {}
  ~UserConnectResponse() override;
  explicit constexpr UserConnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserConnectResponse(const UserConnectResponse& from);
  UserConnectResponse(UserConnectResponse&& from) noexcept
    : UserConnectResponse() {
    *this = ::std::move(from);
  }

  inline UserConnectResponse& operator=(const UserConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserConnectResponse& operator=(UserConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserConnectResponse* internal_default_instance() {
    return reinterpret_cast<const UserConnectResponse*>(
               &_UserConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UserConnectResponse& a, UserConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserConnectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserConnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserConnectResponse* New() const final {
    return new UserConnectResponse();
  }

  UserConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserConnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserConnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserConnectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserConnectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserConnectResponse";
  }
  protected:
  explicit UserConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskStateFieldNumber = 3,
    kLeaderIdFieldNumber = 2,
    kCommandFieldNumber = 1,
  };
  // .TaskState task_state = 3;
  bool has_task_state() const;
  private:
  bool _internal_has_task_state() const;
  public:
  void clear_task_state();
  const ::TaskState& task_state() const;
  PROTOBUF_MUST_USE_RESULT ::TaskState* release_task_state();
  ::TaskState* mutable_task_state();
  void set_allocated_task_state(::TaskState* task_state);
  private:
  const ::TaskState& _internal_task_state() const;
  ::TaskState* _internal_mutable_task_state();
  public:
  void unsafe_arena_set_allocated_task_state(
      ::TaskState* task_state);
  ::TaskState* unsafe_arena_release_task_state();

  // uint64 leader_id = 2;
  void clear_leader_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id() const;
  void set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_id() const;
  void _internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .UserCommand command = 1;
  void clear_command();
  ::UserCommand command() const;
  void set_command(::UserCommand value);
  private:
  ::UserCommand _internal_command() const;
  void _internal_set_command(::UserCommand value);
  public:

  // @@protoc_insertion_point(class_scope:UserConnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskState* task_state_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class WorkerConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerConnectRequest) */ {
 public:
  inline WorkerConnectRequest() : WorkerConnectRequest(nullptr) {}
  ~WorkerConnectRequest() override;
  explicit constexpr WorkerConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerConnectRequest(const WorkerConnectRequest& from);
  WorkerConnectRequest(WorkerConnectRequest&& from) noexcept
    : WorkerConnectRequest() {
    *this = ::std::move(from);
  }

  inline WorkerConnectRequest& operator=(const WorkerConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerConnectRequest& operator=(WorkerConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerConnectRequest* internal_default_instance() {
    return reinterpret_cast<const WorkerConnectRequest*>(
               &_WorkerConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(WorkerConnectRequest& a, WorkerConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerConnectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerConnectRequest* New() const final {
    return new WorkerConnectRequest();
  }

  WorkerConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerConnectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerConnectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerConnectRequest";
  }
  protected:
  explicit WorkerConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskStateFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // .TaskState task_state = 2;
  bool has_task_state() const;
  private:
  bool _internal_has_task_state() const;
  public:
  void clear_task_state();
  const ::TaskState& task_state() const;
  PROTOBUF_MUST_USE_RESULT ::TaskState* release_task_state();
  ::TaskState* mutable_task_state();
  void set_allocated_task_state(::TaskState* task_state);
  private:
  const ::TaskState& _internal_task_state() const;
  ::TaskState* _internal_mutable_task_state();
  public:
  void unsafe_arena_set_allocated_task_state(
      ::TaskState* task_state);
  ::TaskState* unsafe_arena_release_task_state();

  // .WorkerStatus status = 1;
  void clear_status();
  ::WorkerStatus status() const;
  void set_status(::WorkerStatus value);
  private:
  ::WorkerStatus _internal_status() const;
  void _internal_set_status(::WorkerStatus value);
  public:

  // @@protoc_insertion_point(class_scope:WorkerConnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TaskState* task_state_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class WorkerConnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WorkerConnectResponse) */ {
 public:
  inline WorkerConnectResponse() : WorkerConnectResponse(nullptr) {}
  ~WorkerConnectResponse() override;
  explicit constexpr WorkerConnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerConnectResponse(const WorkerConnectResponse& from);
  WorkerConnectResponse(WorkerConnectResponse&& from) noexcept
    : WorkerConnectResponse() {
    *this = ::std::move(from);
  }

  inline WorkerConnectResponse& operator=(const WorkerConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerConnectResponse& operator=(WorkerConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerConnectResponse* internal_default_instance() {
    return reinterpret_cast<const WorkerConnectResponse*>(
               &_WorkerConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(WorkerConnectResponse& a, WorkerConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerConnectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerConnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerConnectResponse* New() const final {
    return new WorkerConnectResponse();
  }

  WorkerConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerConnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerConnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerConnectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerConnectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WorkerConnectResponse";
  }
  protected:
  explicit WorkerConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskDataFieldNumber = 4,
    kTaskIdFieldNumber = 3,
    kLeaderIdFieldNumber = 2,
    kCommandFieldNumber = 1,
  };
  // bytes task_data = 4;
  void clear_task_data();
  const std::string& task_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_data();
  void set_allocated_task_data(std::string* task_data);
  private:
  const std::string& _internal_task_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_data(const std::string& value);
  std::string* _internal_mutable_task_data();
  public:

  // .TaskID task_id = 3;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  const ::TaskID& task_id() const;
  PROTOBUF_MUST_USE_RESULT ::TaskID* release_task_id();
  ::TaskID* mutable_task_id();
  void set_allocated_task_id(::TaskID* task_id);
  private:
  const ::TaskID& _internal_task_id() const;
  ::TaskID* _internal_mutable_task_id();
  public:
  void unsafe_arena_set_allocated_task_id(
      ::TaskID* task_id);
  ::TaskID* unsafe_arena_release_task_id();

  // uint64 leader_id = 2;
  void clear_leader_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id() const;
  void set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_leader_id() const;
  void _internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .WorkerCommand command = 1;
  void clear_command();
  ::WorkerCommand command() const;
  void set_command(::WorkerCommand value);
  private:
  ::WorkerCommand _internal_command() const;
  void _internal_set_command(::WorkerCommand value);
  public:

  // @@protoc_insertion_point(class_scope:WorkerConnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_data_;
  ::TaskID* task_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_id_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class ClientRPCConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientRPCConfig) */ {
 public:
  inline ClientRPCConfig() : ClientRPCConfig(nullptr) {}
  ~ClientRPCConfig() override;
  explicit constexpr ClientRPCConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientRPCConfig(const ClientRPCConfig& from);
  ClientRPCConfig(ClientRPCConfig&& from) noexcept
    : ClientRPCConfig() {
    *this = ::std::move(from);
  }

  inline ClientRPCConfig& operator=(const ClientRPCConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientRPCConfig& operator=(ClientRPCConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientRPCConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientRPCConfig* internal_default_instance() {
    return reinterpret_cast<const ClientRPCConfig*>(
               &_ClientRPCConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ClientRPCConfig& a, ClientRPCConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientRPCConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientRPCConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientRPCConfig* New() const final {
    return new ClientRPCConfig();
  }

  ClientRPCConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientRPCConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientRPCConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientRPCConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientRPCConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientRPCConfig";
  }
  protected:
  explicit ClientRPCConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClusterAddressesFieldNumber = 1,
  };
  // repeated string cluster_addresses = 1;
  int cluster_addresses_size() const;
  private:
  int _internal_cluster_addresses_size() const;
  public:
  void clear_cluster_addresses();
  const std::string& cluster_addresses(int index) const;
  std::string* mutable_cluster_addresses(int index);
  void set_cluster_addresses(int index, const std::string& value);
  void set_cluster_addresses(int index, std::string&& value);
  void set_cluster_addresses(int index, const char* value);
  void set_cluster_addresses(int index, const char* value, size_t size);
  std::string* add_cluster_addresses();
  void add_cluster_addresses(const std::string& value);
  void add_cluster_addresses(std::string&& value);
  void add_cluster_addresses(const char* value);
  void add_cluster_addresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cluster_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cluster_addresses();
  private:
  const std::string& _internal_cluster_addresses(int index) const;
  std::string* _internal_add_cluster_addresses();
  public:

  // @@protoc_insertion_point(class_scope:ClientRPCConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cluster_addresses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// -------------------------------------------------------------------

class RaftConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftConfig) */ {
 public:
  inline RaftConfig() : RaftConfig(nullptr) {}
  ~RaftConfig() override;
  explicit constexpr RaftConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftConfig(const RaftConfig& from);
  RaftConfig(RaftConfig&& from) noexcept
    : RaftConfig() {
    *this = ::std::move(from);
  }

  inline RaftConfig& operator=(const RaftConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftConfig& operator=(RaftConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaftConfig* internal_default_instance() {
    return reinterpret_cast<const RaftConfig*>(
               &_RaftConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RaftConfig& a, RaftConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RaftConfig* New() const final {
    return new RaftConfig();
  }

  RaftConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RaftConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RaftConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftConfig";
  }
  protected:
  explicit RaftConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 4,
    kWorkersFieldNumber = 5,
    kUserAddressFieldNumber = 1,
    kRaftAddressFieldNumber = 2,
    kWorkerAddressFieldNumber = 3,
  };
  // repeated string peers = 4;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  const std::string& peers(int index) const;
  std::string* mutable_peers(int index);
  void set_peers(int index, const std::string& value);
  void set_peers(int index, std::string&& value);
  void set_peers(int index, const char* value);
  void set_peers(int index, const char* value, size_t size);
  std::string* add_peers();
  void add_peers(const std::string& value);
  void add_peers(std::string&& value);
  void add_peers(const char* value);
  void add_peers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& peers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_peers();
  private:
  const std::string& _internal_peers(int index) const;
  std::string* _internal_add_peers();
  public:

  // repeated string workers = 5;
  int workers_size() const;
  private:
  int _internal_workers_size() const;
  public:
  void clear_workers();
  const std::string& workers(int index) const;
  std::string* mutable_workers(int index);
  void set_workers(int index, const std::string& value);
  void set_workers(int index, std::string&& value);
  void set_workers(int index, const char* value);
  void set_workers(int index, const char* value, size_t size);
  std::string* add_workers();
  void add_workers(const std::string& value);
  void add_workers(std::string&& value);
  void add_workers(const char* value);
  void add_workers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& workers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_workers();
  private:
  const std::string& _internal_workers(int index) const;
  std::string* _internal_add_workers();
  public:

  // string user_address = 1;
  void clear_user_address();
  const std::string& user_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_address();
  void set_allocated_user_address(std::string* user_address);
  private:
  const std::string& _internal_user_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_address(const std::string& value);
  std::string* _internal_mutable_user_address();
  public:

  // string raft_address = 2;
  void clear_raft_address();
  const std::string& raft_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raft_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raft_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_raft_address();
  void set_allocated_raft_address(std::string* raft_address);
  private:
  const std::string& _internal_raft_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raft_address(const std::string& value);
  std::string* _internal_mutable_raft_address();
  public:

  // string worker_address = 3;
  void clear_worker_address();
  const std::string& worker_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_worker_address();
  void set_allocated_worker_address(std::string* worker_address);
  private:
  const std::string& _internal_worker_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_address(const std::string& value);
  std::string* _internal_mutable_worker_address();
  public:

  // @@protoc_insertion_point(class_scope:RaftConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> peers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> workers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raft_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_abeille_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TaskID

// uint64 number = 1;
inline void TaskID::clear_number() {
  number_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskID::_internal_number() const {
  return number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskID::number() const {
  // @@protoc_insertion_point(field_get:TaskID.number)
  return _internal_number();
}
inline void TaskID::_internal_set_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  number_ = value;
}
inline void TaskID::set_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:TaskID.number)
}

// uint64 client_id = 2;
inline void TaskID::clear_client_id() {
  client_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskID::_internal_client_id() const {
  return client_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskID::client_id() const {
  // @@protoc_insertion_point(field_get:TaskID.client_id)
  return _internal_client_id();
}
inline void TaskID::_internal_set_client_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  client_id_ = value;
}
inline void TaskID::set_client_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:TaskID.client_id)
}

// -------------------------------------------------------------------

// TaskState

// .TaskID task_id = 1;
inline bool TaskState::_internal_has_task_id() const {
  return this != internal_default_instance() && task_id_ != nullptr;
}
inline bool TaskState::has_task_id() const {
  return _internal_has_task_id();
}
inline void TaskState::clear_task_id() {
  if (GetArenaForAllocation() == nullptr && task_id_ != nullptr) {
    delete task_id_;
  }
  task_id_ = nullptr;
}
inline const ::TaskID& TaskState::_internal_task_id() const {
  const ::TaskID* p = task_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskID&>(
      ::_TaskID_default_instance_);
}
inline const ::TaskID& TaskState::task_id() const {
  // @@protoc_insertion_point(field_get:TaskState.task_id)
  return _internal_task_id();
}
inline void TaskState::unsafe_arena_set_allocated_task_id(
    ::TaskID* task_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_id_);
  }
  task_id_ = task_id;
  if (task_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TaskState.task_id)
}
inline ::TaskID* TaskState::release_task_id() {
  
  ::TaskID* temp = task_id_;
  task_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskID* TaskState::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_release:TaskState.task_id)
  
  ::TaskID* temp = task_id_;
  task_id_ = nullptr;
  return temp;
}
inline ::TaskID* TaskState::_internal_mutable_task_id() {
  
  if (task_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskID>(GetArenaForAllocation());
    task_id_ = p;
  }
  return task_id_;
}
inline ::TaskID* TaskState::mutable_task_id() {
  ::TaskID* _msg = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:TaskState.task_id)
  return _msg;
}
inline void TaskState::set_allocated_task_id(::TaskID* task_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_id_;
  }
  if (task_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskID>::GetOwningArena(task_id);
    if (message_arena != submessage_arena) {
      task_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    
  } else {
    
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:TaskState.task_id)
}

// bytes task_result = 2;
inline void TaskState::clear_task_result() {
  task_result_.ClearToEmpty();
}
inline const std::string& TaskState::task_result() const {
  // @@protoc_insertion_point(field_get:TaskState.task_result)
  return _internal_task_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskState::set_task_result(ArgT0&& arg0, ArgT... args) {
 
 task_result_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TaskState.task_result)
}
inline std::string* TaskState::mutable_task_result() {
  std::string* _s = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:TaskState.task_result)
  return _s;
}
inline const std::string& TaskState::_internal_task_result() const {
  return task_result_.Get();
}
inline void TaskState::_internal_set_task_result(const std::string& value) {
  
  task_result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskState::_internal_mutable_task_result() {
  
  return task_result_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskState::release_task_result() {
  // @@protoc_insertion_point(field_release:TaskState.task_result)
  return task_result_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskState::set_allocated_task_result(std::string* task_result) {
  if (task_result != nullptr) {
    
  } else {
    
  }
  task_result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_result,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TaskState.task_result)
}

// -------------------------------------------------------------------

// TaskWrapper

// .TaskID task_id = 1;
inline bool TaskWrapper::_internal_has_task_id() const {
  return this != internal_default_instance() && task_id_ != nullptr;
}
inline bool TaskWrapper::has_task_id() const {
  return _internal_has_task_id();
}
inline void TaskWrapper::clear_task_id() {
  if (GetArenaForAllocation() == nullptr && task_id_ != nullptr) {
    delete task_id_;
  }
  task_id_ = nullptr;
}
inline const ::TaskID& TaskWrapper::_internal_task_id() const {
  const ::TaskID* p = task_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskID&>(
      ::_TaskID_default_instance_);
}
inline const ::TaskID& TaskWrapper::task_id() const {
  // @@protoc_insertion_point(field_get:TaskWrapper.task_id)
  return _internal_task_id();
}
inline void TaskWrapper::unsafe_arena_set_allocated_task_id(
    ::TaskID* task_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_id_);
  }
  task_id_ = task_id;
  if (task_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TaskWrapper.task_id)
}
inline ::TaskID* TaskWrapper::release_task_id() {
  
  ::TaskID* temp = task_id_;
  task_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskID* TaskWrapper::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_release:TaskWrapper.task_id)
  
  ::TaskID* temp = task_id_;
  task_id_ = nullptr;
  return temp;
}
inline ::TaskID* TaskWrapper::_internal_mutable_task_id() {
  
  if (task_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskID>(GetArenaForAllocation());
    task_id_ = p;
  }
  return task_id_;
}
inline ::TaskID* TaskWrapper::mutable_task_id() {
  ::TaskID* _msg = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:TaskWrapper.task_id)
  return _msg;
}
inline void TaskWrapper::set_allocated_task_id(::TaskID* task_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_id_;
  }
  if (task_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskID>::GetOwningArena(task_id);
    if (message_arena != submessage_arena) {
      task_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    
  } else {
    
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:TaskWrapper.task_id)
}

// uint64 worker_id = 2;
inline void TaskWrapper::clear_worker_id() {
  worker_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskWrapper::_internal_worker_id() const {
  return worker_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskWrapper::worker_id() const {
  // @@protoc_insertion_point(field_get:TaskWrapper.worker_id)
  return _internal_worker_id();
}
inline void TaskWrapper::_internal_set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  worker_id_ = value;
}
inline void TaskWrapper::set_worker_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_worker_id(value);
  // @@protoc_insertion_point(field_set:TaskWrapper.worker_id)
}

// bytes task_data = 3;
inline void TaskWrapper::clear_task_data() {
  task_data_.ClearToEmpty();
}
inline const std::string& TaskWrapper::task_data() const {
  // @@protoc_insertion_point(field_get:TaskWrapper.task_data)
  return _internal_task_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskWrapper::set_task_data(ArgT0&& arg0, ArgT... args) {
 
 task_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TaskWrapper.task_data)
}
inline std::string* TaskWrapper::mutable_task_data() {
  std::string* _s = _internal_mutable_task_data();
  // @@protoc_insertion_point(field_mutable:TaskWrapper.task_data)
  return _s;
}
inline const std::string& TaskWrapper::_internal_task_data() const {
  return task_data_.Get();
}
inline void TaskWrapper::_internal_set_task_data(const std::string& value) {
  
  task_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskWrapper::_internal_mutable_task_data() {
  
  return task_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskWrapper::release_task_data() {
  // @@protoc_insertion_point(field_release:TaskWrapper.task_data)
  return task_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskWrapper::set_allocated_task_data(std::string* task_data) {
  if (task_data != nullptr) {
    
  } else {
    
  }
  task_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TaskWrapper.task_data)
}

// bytes task_result = 4;
inline void TaskWrapper::clear_task_result() {
  task_result_.ClearToEmpty();
}
inline const std::string& TaskWrapper::task_result() const {
  // @@protoc_insertion_point(field_get:TaskWrapper.task_result)
  return _internal_task_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskWrapper::set_task_result(ArgT0&& arg0, ArgT... args) {
 
 task_result_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TaskWrapper.task_result)
}
inline std::string* TaskWrapper::mutable_task_result() {
  std::string* _s = _internal_mutable_task_result();
  // @@protoc_insertion_point(field_mutable:TaskWrapper.task_result)
  return _s;
}
inline const std::string& TaskWrapper::_internal_task_result() const {
  return task_result_.Get();
}
inline void TaskWrapper::_internal_set_task_result(const std::string& value) {
  
  task_result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskWrapper::_internal_mutable_task_result() {
  
  return task_result_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskWrapper::release_task_result() {
  // @@protoc_insertion_point(field_release:TaskWrapper.task_result)
  return task_result_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskWrapper::set_allocated_task_result(std::string* task_result) {
  if (task_result != nullptr) {
    
  } else {
    
  }
  task_result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_result,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TaskWrapper.task_result)
}

// -------------------------------------------------------------------

// AddRequest

// .TaskStatus to = 1;
inline void AddRequest::clear_to() {
  to_ = 0;
}
inline ::TaskStatus AddRequest::_internal_to() const {
  return static_cast< ::TaskStatus >(to_);
}
inline ::TaskStatus AddRequest::to() const {
  // @@protoc_insertion_point(field_get:AddRequest.to)
  return _internal_to();
}
inline void AddRequest::_internal_set_to(::TaskStatus value) {
  
  to_ = value;
}
inline void AddRequest::set_to(::TaskStatus value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:AddRequest.to)
}

// -------------------------------------------------------------------

// MoveRequest

// .TaskStatus to = 1;
inline void MoveRequest::clear_to() {
  to_ = 0;
}
inline ::TaskStatus MoveRequest::_internal_to() const {
  return static_cast< ::TaskStatus >(to_);
}
inline ::TaskStatus MoveRequest::to() const {
  // @@protoc_insertion_point(field_get:MoveRequest.to)
  return _internal_to();
}
inline void MoveRequest::_internal_set_to(::TaskStatus value) {
  
  to_ = value;
}
inline void MoveRequest::set_to(::TaskStatus value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:MoveRequest.to)
}

// .TaskStatus from = 2;
inline void MoveRequest::clear_from() {
  from_ = 0;
}
inline ::TaskStatus MoveRequest::_internal_from() const {
  return static_cast< ::TaskStatus >(from_);
}
inline ::TaskStatus MoveRequest::from() const {
  // @@protoc_insertion_point(field_get:MoveRequest.from)
  return _internal_from();
}
inline void MoveRequest::_internal_set_from(::TaskStatus value) {
  
  from_ = value;
}
inline void MoveRequest::set_from(::TaskStatus value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:MoveRequest.from)
}

// -------------------------------------------------------------------

// Entry

// .RaftCommand command = 1;
inline void Entry::clear_command() {
  command_ = 0;
}
inline ::RaftCommand Entry::_internal_command() const {
  return static_cast< ::RaftCommand >(command_);
}
inline ::RaftCommand Entry::command() const {
  // @@protoc_insertion_point(field_get:Entry.command)
  return _internal_command();
}
inline void Entry::_internal_set_command(::RaftCommand value) {
  
  command_ = value;
}
inline void Entry::set_command(::RaftCommand value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:Entry.command)
}

// uint64 term = 2;
inline void Entry::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Entry::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Entry::term() const {
  // @@protoc_insertion_point(field_get:Entry.term)
  return _internal_term();
}
inline void Entry::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void Entry::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:Entry.term)
}

// .TaskWrapper task_wrapper = 3;
inline bool Entry::_internal_has_task_wrapper() const {
  return this != internal_default_instance() && task_wrapper_ != nullptr;
}
inline bool Entry::has_task_wrapper() const {
  return _internal_has_task_wrapper();
}
inline void Entry::clear_task_wrapper() {
  if (GetArenaForAllocation() == nullptr && task_wrapper_ != nullptr) {
    delete task_wrapper_;
  }
  task_wrapper_ = nullptr;
}
inline const ::TaskWrapper& Entry::_internal_task_wrapper() const {
  const ::TaskWrapper* p = task_wrapper_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskWrapper&>(
      ::_TaskWrapper_default_instance_);
}
inline const ::TaskWrapper& Entry::task_wrapper() const {
  // @@protoc_insertion_point(field_get:Entry.task_wrapper)
  return _internal_task_wrapper();
}
inline void Entry::unsafe_arena_set_allocated_task_wrapper(
    ::TaskWrapper* task_wrapper) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_wrapper_);
  }
  task_wrapper_ = task_wrapper;
  if (task_wrapper) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Entry.task_wrapper)
}
inline ::TaskWrapper* Entry::release_task_wrapper() {
  
  ::TaskWrapper* temp = task_wrapper_;
  task_wrapper_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskWrapper* Entry::unsafe_arena_release_task_wrapper() {
  // @@protoc_insertion_point(field_release:Entry.task_wrapper)
  
  ::TaskWrapper* temp = task_wrapper_;
  task_wrapper_ = nullptr;
  return temp;
}
inline ::TaskWrapper* Entry::_internal_mutable_task_wrapper() {
  
  if (task_wrapper_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskWrapper>(GetArenaForAllocation());
    task_wrapper_ = p;
  }
  return task_wrapper_;
}
inline ::TaskWrapper* Entry::mutable_task_wrapper() {
  ::TaskWrapper* _msg = _internal_mutable_task_wrapper();
  // @@protoc_insertion_point(field_mutable:Entry.task_wrapper)
  return _msg;
}
inline void Entry::set_allocated_task_wrapper(::TaskWrapper* task_wrapper) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_wrapper_;
  }
  if (task_wrapper) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskWrapper>::GetOwningArena(task_wrapper);
    if (message_arena != submessage_arena) {
      task_wrapper = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_wrapper, submessage_arena);
    }
    
  } else {
    
  }
  task_wrapper_ = task_wrapper;
  // @@protoc_insertion_point(field_set_allocated:Entry.task_wrapper)
}

// .AddRequest add_request = 4;
inline bool Entry::_internal_has_add_request() const {
  return this != internal_default_instance() && add_request_ != nullptr;
}
inline bool Entry::has_add_request() const {
  return _internal_has_add_request();
}
inline void Entry::clear_add_request() {
  if (GetArenaForAllocation() == nullptr && add_request_ != nullptr) {
    delete add_request_;
  }
  add_request_ = nullptr;
}
inline const ::AddRequest& Entry::_internal_add_request() const {
  const ::AddRequest* p = add_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::AddRequest&>(
      ::_AddRequest_default_instance_);
}
inline const ::AddRequest& Entry::add_request() const {
  // @@protoc_insertion_point(field_get:Entry.add_request)
  return _internal_add_request();
}
inline void Entry::unsafe_arena_set_allocated_add_request(
    ::AddRequest* add_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(add_request_);
  }
  add_request_ = add_request;
  if (add_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Entry.add_request)
}
inline ::AddRequest* Entry::release_add_request() {
  
  ::AddRequest* temp = add_request_;
  add_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AddRequest* Entry::unsafe_arena_release_add_request() {
  // @@protoc_insertion_point(field_release:Entry.add_request)
  
  ::AddRequest* temp = add_request_;
  add_request_ = nullptr;
  return temp;
}
inline ::AddRequest* Entry::_internal_mutable_add_request() {
  
  if (add_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::AddRequest>(GetArenaForAllocation());
    add_request_ = p;
  }
  return add_request_;
}
inline ::AddRequest* Entry::mutable_add_request() {
  ::AddRequest* _msg = _internal_mutable_add_request();
  // @@protoc_insertion_point(field_mutable:Entry.add_request)
  return _msg;
}
inline void Entry::set_allocated_add_request(::AddRequest* add_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete add_request_;
  }
  if (add_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::AddRequest>::GetOwningArena(add_request);
    if (message_arena != submessage_arena) {
      add_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, add_request, submessage_arena);
    }
    
  } else {
    
  }
  add_request_ = add_request;
  // @@protoc_insertion_point(field_set_allocated:Entry.add_request)
}

// .MoveRequest move_request = 5;
inline bool Entry::_internal_has_move_request() const {
  return this != internal_default_instance() && move_request_ != nullptr;
}
inline bool Entry::has_move_request() const {
  return _internal_has_move_request();
}
inline void Entry::clear_move_request() {
  if (GetArenaForAllocation() == nullptr && move_request_ != nullptr) {
    delete move_request_;
  }
  move_request_ = nullptr;
}
inline const ::MoveRequest& Entry::_internal_move_request() const {
  const ::MoveRequest* p = move_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::MoveRequest&>(
      ::_MoveRequest_default_instance_);
}
inline const ::MoveRequest& Entry::move_request() const {
  // @@protoc_insertion_point(field_get:Entry.move_request)
  return _internal_move_request();
}
inline void Entry::unsafe_arena_set_allocated_move_request(
    ::MoveRequest* move_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(move_request_);
  }
  move_request_ = move_request;
  if (move_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Entry.move_request)
}
inline ::MoveRequest* Entry::release_move_request() {
  
  ::MoveRequest* temp = move_request_;
  move_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MoveRequest* Entry::unsafe_arena_release_move_request() {
  // @@protoc_insertion_point(field_release:Entry.move_request)
  
  ::MoveRequest* temp = move_request_;
  move_request_ = nullptr;
  return temp;
}
inline ::MoveRequest* Entry::_internal_mutable_move_request() {
  
  if (move_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::MoveRequest>(GetArenaForAllocation());
    move_request_ = p;
  }
  return move_request_;
}
inline ::MoveRequest* Entry::mutable_move_request() {
  ::MoveRequest* _msg = _internal_mutable_move_request();
  // @@protoc_insertion_point(field_mutable:Entry.move_request)
  return _msg;
}
inline void Entry::set_allocated_move_request(::MoveRequest* move_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete move_request_;
  }
  if (move_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MoveRequest>::GetOwningArena(move_request);
    if (message_arena != submessage_arena) {
      move_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move_request, submessage_arena);
    }
    
  } else {
    
  }
  move_request_ = move_request;
  // @@protoc_insertion_point(field_set_allocated:Entry.move_request)
}

// -------------------------------------------------------------------

// AppendEntryRequest

// uint64 term = 1;
inline void AppendEntryRequest::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::term() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.term)
  return _internal_term();
}
inline void AppendEntryRequest::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void AppendEntryRequest::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.term)
}

// uint64 leader_id = 2;
inline void AppendEntryRequest::clear_leader_id() {
  leader_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_leader_id() const {
  return leader_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::leader_id() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.leader_id)
  return _internal_leader_id();
}
inline void AppendEntryRequest::_internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_id_ = value;
}
inline void AppendEntryRequest::set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_id(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.leader_id)
}

// uint64 prev_log_index = 3;
inline void AppendEntryRequest::clear_prev_log_index() {
  prev_log_index_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_prev_log_index() const {
  return prev_log_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::prev_log_index() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.prev_log_index)
  return _internal_prev_log_index();
}
inline void AppendEntryRequest::_internal_set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  prev_log_index_ = value;
}
inline void AppendEntryRequest::set_prev_log_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_prev_log_index(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.prev_log_index)
}

// uint64 prev_log_term = 4;
inline void AppendEntryRequest::clear_prev_log_term() {
  prev_log_term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_prev_log_term() const {
  return prev_log_term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::prev_log_term() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.prev_log_term)
  return _internal_prev_log_term();
}
inline void AppendEntryRequest::_internal_set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  prev_log_term_ = value;
}
inline void AppendEntryRequest::set_prev_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_prev_log_term(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.prev_log_term)
}

// .Entry entry = 5;
inline bool AppendEntryRequest::_internal_has_entry() const {
  return this != internal_default_instance() && entry_ != nullptr;
}
inline bool AppendEntryRequest::has_entry() const {
  return _internal_has_entry();
}
inline void AppendEntryRequest::clear_entry() {
  if (GetArenaForAllocation() == nullptr && entry_ != nullptr) {
    delete entry_;
  }
  entry_ = nullptr;
}
inline const ::Entry& AppendEntryRequest::_internal_entry() const {
  const ::Entry* p = entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::Entry&>(
      ::_Entry_default_instance_);
}
inline const ::Entry& AppendEntryRequest::entry() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.entry)
  return _internal_entry();
}
inline void AppendEntryRequest::unsafe_arena_set_allocated_entry(
    ::Entry* entry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entry_);
  }
  entry_ = entry;
  if (entry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AppendEntryRequest.entry)
}
inline ::Entry* AppendEntryRequest::release_entry() {
  
  ::Entry* temp = entry_;
  entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Entry* AppendEntryRequest::unsafe_arena_release_entry() {
  // @@protoc_insertion_point(field_release:AppendEntryRequest.entry)
  
  ::Entry* temp = entry_;
  entry_ = nullptr;
  return temp;
}
inline ::Entry* AppendEntryRequest::_internal_mutable_entry() {
  
  if (entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::Entry>(GetArenaForAllocation());
    entry_ = p;
  }
  return entry_;
}
inline ::Entry* AppendEntryRequest::mutable_entry() {
  ::Entry* _msg = _internal_mutable_entry();
  // @@protoc_insertion_point(field_mutable:AppendEntryRequest.entry)
  return _msg;
}
inline void AppendEntryRequest::set_allocated_entry(::Entry* entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete entry_;
  }
  if (entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Entry>::GetOwningArena(entry);
    if (message_arena != submessage_arena) {
      entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    
  } else {
    
  }
  entry_ = entry;
  // @@protoc_insertion_point(field_set_allocated:AppendEntryRequest.entry)
}

// uint64 leader_commit = 6;
inline void AppendEntryRequest::clear_leader_commit() {
  leader_commit_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::_internal_leader_commit() const {
  return leader_commit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryRequest::leader_commit() const {
  // @@protoc_insertion_point(field_get:AppendEntryRequest.leader_commit)
  return _internal_leader_commit();
}
inline void AppendEntryRequest::_internal_set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_commit_ = value;
}
inline void AppendEntryRequest::set_leader_commit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_commit(value);
  // @@protoc_insertion_point(field_set:AppendEntryRequest.leader_commit)
}

// -------------------------------------------------------------------

// AppendEntryResponse

// uint64 term = 1;
inline void AppendEntryResponse::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryResponse::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AppendEntryResponse::term() const {
  // @@protoc_insertion_point(field_get:AppendEntryResponse.term)
  return _internal_term();
}
inline void AppendEntryResponse::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void AppendEntryResponse::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:AppendEntryResponse.term)
}

// bool success = 2;
inline void AppendEntryResponse::clear_success() {
  success_ = false;
}
inline bool AppendEntryResponse::_internal_success() const {
  return success_;
}
inline bool AppendEntryResponse::success() const {
  // @@protoc_insertion_point(field_get:AppendEntryResponse.success)
  return _internal_success();
}
inline void AppendEntryResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void AppendEntryResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:AppendEntryResponse.success)
}

// -------------------------------------------------------------------

// RequestVoteRequest

// uint64 term = 1;
inline void RequestVoteRequest::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::term() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.term)
  return _internal_term();
}
inline void RequestVoteRequest::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void RequestVoteRequest::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.term)
}

// uint64 candidate_id = 2;
inline void RequestVoteRequest::clear_candidate_id() {
  candidate_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_candidate_id() const {
  return candidate_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::candidate_id() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.candidate_id)
  return _internal_candidate_id();
}
inline void RequestVoteRequest::_internal_set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  candidate_id_ = value;
}
inline void RequestVoteRequest::set_candidate_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_candidate_id(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.candidate_id)
}

// uint64 last_log_entry = 3;
inline void RequestVoteRequest::clear_last_log_entry() {
  last_log_entry_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_last_log_entry() const {
  return last_log_entry_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::last_log_entry() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.last_log_entry)
  return _internal_last_log_entry();
}
inline void RequestVoteRequest::_internal_set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  last_log_entry_ = value;
}
inline void RequestVoteRequest::set_last_log_entry(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_log_entry(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.last_log_entry)
}

// uint64 last_log_term = 4;
inline void RequestVoteRequest::clear_last_log_term() {
  last_log_term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::_internal_last_log_term() const {
  return last_log_term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteRequest::last_log_term() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.last_log_term)
  return _internal_last_log_term();
}
inline void RequestVoteRequest::_internal_set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  last_log_term_ = value;
}
inline void RequestVoteRequest::set_last_log_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_log_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.last_log_term)
}

// -------------------------------------------------------------------

// RequestVoteResponse

// uint64 term = 1;
inline void RequestVoteResponse::clear_term() {
  term_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteResponse::_internal_term() const {
  return term_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestVoteResponse::term() const {
  // @@protoc_insertion_point(field_get:RequestVoteResponse.term)
  return _internal_term();
}
inline void RequestVoteResponse::_internal_set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  term_ = value;
}
inline void RequestVoteResponse::set_term(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteResponse.term)
}

// bool vote_granted = 2;
inline void RequestVoteResponse::clear_vote_granted() {
  vote_granted_ = false;
}
inline bool RequestVoteResponse::_internal_vote_granted() const {
  return vote_granted_;
}
inline bool RequestVoteResponse::vote_granted() const {
  // @@protoc_insertion_point(field_get:RequestVoteResponse.vote_granted)
  return _internal_vote_granted();
}
inline void RequestVoteResponse::_internal_set_vote_granted(bool value) {
  
  vote_granted_ = value;
}
inline void RequestVoteResponse::set_vote_granted(bool value) {
  _internal_set_vote_granted(value);
  // @@protoc_insertion_point(field_set:RequestVoteResponse.vote_granted)
}

// -------------------------------------------------------------------

// UserConnectRequest

// .UserStatus status = 1;
inline void UserConnectRequest::clear_status() {
  status_ = 0;
}
inline ::UserStatus UserConnectRequest::_internal_status() const {
  return static_cast< ::UserStatus >(status_);
}
inline ::UserStatus UserConnectRequest::status() const {
  // @@protoc_insertion_point(field_get:UserConnectRequest.status)
  return _internal_status();
}
inline void UserConnectRequest::_internal_set_status(::UserStatus value) {
  
  status_ = value;
}
inline void UserConnectRequest::set_status(::UserStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:UserConnectRequest.status)
}

// bytes task_data = 2;
inline void UserConnectRequest::clear_task_data() {
  task_data_.ClearToEmpty();
}
inline const std::string& UserConnectRequest::task_data() const {
  // @@protoc_insertion_point(field_get:UserConnectRequest.task_data)
  return _internal_task_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserConnectRequest::set_task_data(ArgT0&& arg0, ArgT... args) {
 
 task_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserConnectRequest.task_data)
}
inline std::string* UserConnectRequest::mutable_task_data() {
  std::string* _s = _internal_mutable_task_data();
  // @@protoc_insertion_point(field_mutable:UserConnectRequest.task_data)
  return _s;
}
inline const std::string& UserConnectRequest::_internal_task_data() const {
  return task_data_.Get();
}
inline void UserConnectRequest::_internal_set_task_data(const std::string& value) {
  
  task_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserConnectRequest::_internal_mutable_task_data() {
  
  return task_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserConnectRequest::release_task_data() {
  // @@protoc_insertion_point(field_release:UserConnectRequest.task_data)
  return task_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserConnectRequest::set_allocated_task_data(std::string* task_data) {
  if (task_data != nullptr) {
    
  } else {
    
  }
  task_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:UserConnectRequest.task_data)
}

// -------------------------------------------------------------------

// UserConnectResponse

// .UserCommand command = 1;
inline void UserConnectResponse::clear_command() {
  command_ = 0;
}
inline ::UserCommand UserConnectResponse::_internal_command() const {
  return static_cast< ::UserCommand >(command_);
}
inline ::UserCommand UserConnectResponse::command() const {
  // @@protoc_insertion_point(field_get:UserConnectResponse.command)
  return _internal_command();
}
inline void UserConnectResponse::_internal_set_command(::UserCommand value) {
  
  command_ = value;
}
inline void UserConnectResponse::set_command(::UserCommand value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:UserConnectResponse.command)
}

// uint64 leader_id = 2;
inline void UserConnectResponse::clear_leader_id() {
  leader_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserConnectResponse::_internal_leader_id() const {
  return leader_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserConnectResponse::leader_id() const {
  // @@protoc_insertion_point(field_get:UserConnectResponse.leader_id)
  return _internal_leader_id();
}
inline void UserConnectResponse::_internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_id_ = value;
}
inline void UserConnectResponse::set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_id(value);
  // @@protoc_insertion_point(field_set:UserConnectResponse.leader_id)
}

// .TaskState task_state = 3;
inline bool UserConnectResponse::_internal_has_task_state() const {
  return this != internal_default_instance() && task_state_ != nullptr;
}
inline bool UserConnectResponse::has_task_state() const {
  return _internal_has_task_state();
}
inline void UserConnectResponse::clear_task_state() {
  if (GetArenaForAllocation() == nullptr && task_state_ != nullptr) {
    delete task_state_;
  }
  task_state_ = nullptr;
}
inline const ::TaskState& UserConnectResponse::_internal_task_state() const {
  const ::TaskState* p = task_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskState&>(
      ::_TaskState_default_instance_);
}
inline const ::TaskState& UserConnectResponse::task_state() const {
  // @@protoc_insertion_point(field_get:UserConnectResponse.task_state)
  return _internal_task_state();
}
inline void UserConnectResponse::unsafe_arena_set_allocated_task_state(
    ::TaskState* task_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_state_);
  }
  task_state_ = task_state;
  if (task_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserConnectResponse.task_state)
}
inline ::TaskState* UserConnectResponse::release_task_state() {
  
  ::TaskState* temp = task_state_;
  task_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskState* UserConnectResponse::unsafe_arena_release_task_state() {
  // @@protoc_insertion_point(field_release:UserConnectResponse.task_state)
  
  ::TaskState* temp = task_state_;
  task_state_ = nullptr;
  return temp;
}
inline ::TaskState* UserConnectResponse::_internal_mutable_task_state() {
  
  if (task_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskState>(GetArenaForAllocation());
    task_state_ = p;
  }
  return task_state_;
}
inline ::TaskState* UserConnectResponse::mutable_task_state() {
  ::TaskState* _msg = _internal_mutable_task_state();
  // @@protoc_insertion_point(field_mutable:UserConnectResponse.task_state)
  return _msg;
}
inline void UserConnectResponse::set_allocated_task_state(::TaskState* task_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_state_;
  }
  if (task_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskState>::GetOwningArena(task_state);
    if (message_arena != submessage_arena) {
      task_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_state, submessage_arena);
    }
    
  } else {
    
  }
  task_state_ = task_state;
  // @@protoc_insertion_point(field_set_allocated:UserConnectResponse.task_state)
}

// -------------------------------------------------------------------

// WorkerConnectRequest

// .WorkerStatus status = 1;
inline void WorkerConnectRequest::clear_status() {
  status_ = 0;
}
inline ::WorkerStatus WorkerConnectRequest::_internal_status() const {
  return static_cast< ::WorkerStatus >(status_);
}
inline ::WorkerStatus WorkerConnectRequest::status() const {
  // @@protoc_insertion_point(field_get:WorkerConnectRequest.status)
  return _internal_status();
}
inline void WorkerConnectRequest::_internal_set_status(::WorkerStatus value) {
  
  status_ = value;
}
inline void WorkerConnectRequest::set_status(::WorkerStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:WorkerConnectRequest.status)
}

// .TaskState task_state = 2;
inline bool WorkerConnectRequest::_internal_has_task_state() const {
  return this != internal_default_instance() && task_state_ != nullptr;
}
inline bool WorkerConnectRequest::has_task_state() const {
  return _internal_has_task_state();
}
inline void WorkerConnectRequest::clear_task_state() {
  if (GetArenaForAllocation() == nullptr && task_state_ != nullptr) {
    delete task_state_;
  }
  task_state_ = nullptr;
}
inline const ::TaskState& WorkerConnectRequest::_internal_task_state() const {
  const ::TaskState* p = task_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskState&>(
      ::_TaskState_default_instance_);
}
inline const ::TaskState& WorkerConnectRequest::task_state() const {
  // @@protoc_insertion_point(field_get:WorkerConnectRequest.task_state)
  return _internal_task_state();
}
inline void WorkerConnectRequest::unsafe_arena_set_allocated_task_state(
    ::TaskState* task_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_state_);
  }
  task_state_ = task_state;
  if (task_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerConnectRequest.task_state)
}
inline ::TaskState* WorkerConnectRequest::release_task_state() {
  
  ::TaskState* temp = task_state_;
  task_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskState* WorkerConnectRequest::unsafe_arena_release_task_state() {
  // @@protoc_insertion_point(field_release:WorkerConnectRequest.task_state)
  
  ::TaskState* temp = task_state_;
  task_state_ = nullptr;
  return temp;
}
inline ::TaskState* WorkerConnectRequest::_internal_mutable_task_state() {
  
  if (task_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskState>(GetArenaForAllocation());
    task_state_ = p;
  }
  return task_state_;
}
inline ::TaskState* WorkerConnectRequest::mutable_task_state() {
  ::TaskState* _msg = _internal_mutable_task_state();
  // @@protoc_insertion_point(field_mutable:WorkerConnectRequest.task_state)
  return _msg;
}
inline void WorkerConnectRequest::set_allocated_task_state(::TaskState* task_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_state_;
  }
  if (task_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskState>::GetOwningArena(task_state);
    if (message_arena != submessage_arena) {
      task_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_state, submessage_arena);
    }
    
  } else {
    
  }
  task_state_ = task_state;
  // @@protoc_insertion_point(field_set_allocated:WorkerConnectRequest.task_state)
}

// -------------------------------------------------------------------

// WorkerConnectResponse

// .WorkerCommand command = 1;
inline void WorkerConnectResponse::clear_command() {
  command_ = 0;
}
inline ::WorkerCommand WorkerConnectResponse::_internal_command() const {
  return static_cast< ::WorkerCommand >(command_);
}
inline ::WorkerCommand WorkerConnectResponse::command() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.command)
  return _internal_command();
}
inline void WorkerConnectResponse::_internal_set_command(::WorkerCommand value) {
  
  command_ = value;
}
inline void WorkerConnectResponse::set_command(::WorkerCommand value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:WorkerConnectResponse.command)
}

// uint64 leader_id = 2;
inline void WorkerConnectResponse::clear_leader_id() {
  leader_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectResponse::_internal_leader_id() const {
  return leader_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WorkerConnectResponse::leader_id() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.leader_id)
  return _internal_leader_id();
}
inline void WorkerConnectResponse::_internal_set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_id_ = value;
}
inline void WorkerConnectResponse::set_leader_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_leader_id(value);
  // @@protoc_insertion_point(field_set:WorkerConnectResponse.leader_id)
}

// .TaskID task_id = 3;
inline bool WorkerConnectResponse::_internal_has_task_id() const {
  return this != internal_default_instance() && task_id_ != nullptr;
}
inline bool WorkerConnectResponse::has_task_id() const {
  return _internal_has_task_id();
}
inline void WorkerConnectResponse::clear_task_id() {
  if (GetArenaForAllocation() == nullptr && task_id_ != nullptr) {
    delete task_id_;
  }
  task_id_ = nullptr;
}
inline const ::TaskID& WorkerConnectResponse::_internal_task_id() const {
  const ::TaskID* p = task_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::TaskID&>(
      ::_TaskID_default_instance_);
}
inline const ::TaskID& WorkerConnectResponse::task_id() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.task_id)
  return _internal_task_id();
}
inline void WorkerConnectResponse::unsafe_arena_set_allocated_task_id(
    ::TaskID* task_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_id_);
  }
  task_id_ = task_id;
  if (task_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WorkerConnectResponse.task_id)
}
inline ::TaskID* WorkerConnectResponse::release_task_id() {
  
  ::TaskID* temp = task_id_;
  task_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TaskID* WorkerConnectResponse::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_release:WorkerConnectResponse.task_id)
  
  ::TaskID* temp = task_id_;
  task_id_ = nullptr;
  return temp;
}
inline ::TaskID* WorkerConnectResponse::_internal_mutable_task_id() {
  
  if (task_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::TaskID>(GetArenaForAllocation());
    task_id_ = p;
  }
  return task_id_;
}
inline ::TaskID* WorkerConnectResponse::mutable_task_id() {
  ::TaskID* _msg = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:WorkerConnectResponse.task_id)
  return _msg;
}
inline void WorkerConnectResponse::set_allocated_task_id(::TaskID* task_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_id_;
  }
  if (task_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TaskID>::GetOwningArena(task_id);
    if (message_arena != submessage_arena) {
      task_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    
  } else {
    
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:WorkerConnectResponse.task_id)
}

// bytes task_data = 4;
inline void WorkerConnectResponse::clear_task_data() {
  task_data_.ClearToEmpty();
}
inline const std::string& WorkerConnectResponse::task_data() const {
  // @@protoc_insertion_point(field_get:WorkerConnectResponse.task_data)
  return _internal_task_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkerConnectResponse::set_task_data(ArgT0&& arg0, ArgT... args) {
 
 task_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WorkerConnectResponse.task_data)
}
inline std::string* WorkerConnectResponse::mutable_task_data() {
  std::string* _s = _internal_mutable_task_data();
  // @@protoc_insertion_point(field_mutable:WorkerConnectResponse.task_data)
  return _s;
}
inline const std::string& WorkerConnectResponse::_internal_task_data() const {
  return task_data_.Get();
}
inline void WorkerConnectResponse::_internal_set_task_data(const std::string& value) {
  
  task_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WorkerConnectResponse::_internal_mutable_task_data() {
  
  return task_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WorkerConnectResponse::release_task_data() {
  // @@protoc_insertion_point(field_release:WorkerConnectResponse.task_data)
  return task_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WorkerConnectResponse::set_allocated_task_data(std::string* task_data) {
  if (task_data != nullptr) {
    
  } else {
    
  }
  task_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:WorkerConnectResponse.task_data)
}

// -------------------------------------------------------------------

// ClientRPCConfig

// repeated string cluster_addresses = 1;
inline int ClientRPCConfig::_internal_cluster_addresses_size() const {
  return cluster_addresses_.size();
}
inline int ClientRPCConfig::cluster_addresses_size() const {
  return _internal_cluster_addresses_size();
}
inline void ClientRPCConfig::clear_cluster_addresses() {
  cluster_addresses_.Clear();
}
inline std::string* ClientRPCConfig::add_cluster_addresses() {
  std::string* _s = _internal_add_cluster_addresses();
  // @@protoc_insertion_point(field_add_mutable:ClientRPCConfig.cluster_addresses)
  return _s;
}
inline const std::string& ClientRPCConfig::_internal_cluster_addresses(int index) const {
  return cluster_addresses_.Get(index);
}
inline const std::string& ClientRPCConfig::cluster_addresses(int index) const {
  // @@protoc_insertion_point(field_get:ClientRPCConfig.cluster_addresses)
  return _internal_cluster_addresses(index);
}
inline std::string* ClientRPCConfig::mutable_cluster_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:ClientRPCConfig.cluster_addresses)
  return cluster_addresses_.Mutable(index);
}
inline void ClientRPCConfig::set_cluster_addresses(int index, const std::string& value) {
  cluster_addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ClientRPCConfig.cluster_addresses)
}
inline void ClientRPCConfig::set_cluster_addresses(int index, std::string&& value) {
  cluster_addresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ClientRPCConfig.cluster_addresses)
}
inline void ClientRPCConfig::set_cluster_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cluster_addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ClientRPCConfig.cluster_addresses)
}
inline void ClientRPCConfig::set_cluster_addresses(int index, const char* value, size_t size) {
  cluster_addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ClientRPCConfig.cluster_addresses)
}
inline std::string* ClientRPCConfig::_internal_add_cluster_addresses() {
  return cluster_addresses_.Add();
}
inline void ClientRPCConfig::add_cluster_addresses(const std::string& value) {
  cluster_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ClientRPCConfig.cluster_addresses)
}
inline void ClientRPCConfig::add_cluster_addresses(std::string&& value) {
  cluster_addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ClientRPCConfig.cluster_addresses)
}
inline void ClientRPCConfig::add_cluster_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cluster_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ClientRPCConfig.cluster_addresses)
}
inline void ClientRPCConfig::add_cluster_addresses(const char* value, size_t size) {
  cluster_addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ClientRPCConfig.cluster_addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ClientRPCConfig::cluster_addresses() const {
  // @@protoc_insertion_point(field_list:ClientRPCConfig.cluster_addresses)
  return cluster_addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ClientRPCConfig::mutable_cluster_addresses() {
  // @@protoc_insertion_point(field_mutable_list:ClientRPCConfig.cluster_addresses)
  return &cluster_addresses_;
}

// -------------------------------------------------------------------

// RaftConfig

// string user_address = 1;
inline void RaftConfig::clear_user_address() {
  user_address_.ClearToEmpty();
}
inline const std::string& RaftConfig::user_address() const {
  // @@protoc_insertion_point(field_get:RaftConfig.user_address)
  return _internal_user_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RaftConfig::set_user_address(ArgT0&& arg0, ArgT... args) {
 
 user_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RaftConfig.user_address)
}
inline std::string* RaftConfig::mutable_user_address() {
  std::string* _s = _internal_mutable_user_address();
  // @@protoc_insertion_point(field_mutable:RaftConfig.user_address)
  return _s;
}
inline const std::string& RaftConfig::_internal_user_address() const {
  return user_address_.Get();
}
inline void RaftConfig::_internal_set_user_address(const std::string& value) {
  
  user_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RaftConfig::_internal_mutable_user_address() {
  
  return user_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RaftConfig::release_user_address() {
  // @@protoc_insertion_point(field_release:RaftConfig.user_address)
  return user_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RaftConfig::set_allocated_user_address(std::string* user_address) {
  if (user_address != nullptr) {
    
  } else {
    
  }
  user_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RaftConfig.user_address)
}

// string raft_address = 2;
inline void RaftConfig::clear_raft_address() {
  raft_address_.ClearToEmpty();
}
inline const std::string& RaftConfig::raft_address() const {
  // @@protoc_insertion_point(field_get:RaftConfig.raft_address)
  return _internal_raft_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RaftConfig::set_raft_address(ArgT0&& arg0, ArgT... args) {
 
 raft_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RaftConfig.raft_address)
}
inline std::string* RaftConfig::mutable_raft_address() {
  std::string* _s = _internal_mutable_raft_address();
  // @@protoc_insertion_point(field_mutable:RaftConfig.raft_address)
  return _s;
}
inline const std::string& RaftConfig::_internal_raft_address() const {
  return raft_address_.Get();
}
inline void RaftConfig::_internal_set_raft_address(const std::string& value) {
  
  raft_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RaftConfig::_internal_mutable_raft_address() {
  
  return raft_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RaftConfig::release_raft_address() {
  // @@protoc_insertion_point(field_release:RaftConfig.raft_address)
  return raft_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RaftConfig::set_allocated_raft_address(std::string* raft_address) {
  if (raft_address != nullptr) {
    
  } else {
    
  }
  raft_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raft_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RaftConfig.raft_address)
}

// string worker_address = 3;
inline void RaftConfig::clear_worker_address() {
  worker_address_.ClearToEmpty();
}
inline const std::string& RaftConfig::worker_address() const {
  // @@protoc_insertion_point(field_get:RaftConfig.worker_address)
  return _internal_worker_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RaftConfig::set_worker_address(ArgT0&& arg0, ArgT... args) {
 
 worker_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RaftConfig.worker_address)
}
inline std::string* RaftConfig::mutable_worker_address() {
  std::string* _s = _internal_mutable_worker_address();
  // @@protoc_insertion_point(field_mutable:RaftConfig.worker_address)
  return _s;
}
inline const std::string& RaftConfig::_internal_worker_address() const {
  return worker_address_.Get();
}
inline void RaftConfig::_internal_set_worker_address(const std::string& value) {
  
  worker_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RaftConfig::_internal_mutable_worker_address() {
  
  return worker_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RaftConfig::release_worker_address() {
  // @@protoc_insertion_point(field_release:RaftConfig.worker_address)
  return worker_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RaftConfig::set_allocated_worker_address(std::string* worker_address) {
  if (worker_address != nullptr) {
    
  } else {
    
  }
  worker_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), worker_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RaftConfig.worker_address)
}

// repeated string peers = 4;
inline int RaftConfig::_internal_peers_size() const {
  return peers_.size();
}
inline int RaftConfig::peers_size() const {
  return _internal_peers_size();
}
inline void RaftConfig::clear_peers() {
  peers_.Clear();
}
inline std::string* RaftConfig::add_peers() {
  std::string* _s = _internal_add_peers();
  // @@protoc_insertion_point(field_add_mutable:RaftConfig.peers)
  return _s;
}
inline const std::string& RaftConfig::_internal_peers(int index) const {
  return peers_.Get(index);
}
inline const std::string& RaftConfig::peers(int index) const {
  // @@protoc_insertion_point(field_get:RaftConfig.peers)
  return _internal_peers(index);
}
inline std::string* RaftConfig::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:RaftConfig.peers)
  return peers_.Mutable(index);
}
inline void RaftConfig::set_peers(int index, const std::string& value) {
  peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:RaftConfig.peers)
}
inline void RaftConfig::set_peers(int index, std::string&& value) {
  peers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:RaftConfig.peers)
}
inline void RaftConfig::set_peers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RaftConfig.peers)
}
inline void RaftConfig::set_peers(int index, const char* value, size_t size) {
  peers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RaftConfig.peers)
}
inline std::string* RaftConfig::_internal_add_peers() {
  return peers_.Add();
}
inline void RaftConfig::add_peers(const std::string& value) {
  peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RaftConfig.peers)
}
inline void RaftConfig::add_peers(std::string&& value) {
  peers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RaftConfig.peers)
}
inline void RaftConfig::add_peers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RaftConfig.peers)
}
inline void RaftConfig::add_peers(const char* value, size_t size) {
  peers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RaftConfig.peers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RaftConfig::peers() const {
  // @@protoc_insertion_point(field_list:RaftConfig.peers)
  return peers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RaftConfig::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:RaftConfig.peers)
  return &peers_;
}

// repeated string workers = 5;
inline int RaftConfig::_internal_workers_size() const {
  return workers_.size();
}
inline int RaftConfig::workers_size() const {
  return _internal_workers_size();
}
inline void RaftConfig::clear_workers() {
  workers_.Clear();
}
inline std::string* RaftConfig::add_workers() {
  std::string* _s = _internal_add_workers();
  // @@protoc_insertion_point(field_add_mutable:RaftConfig.workers)
  return _s;
}
inline const std::string& RaftConfig::_internal_workers(int index) const {
  return workers_.Get(index);
}
inline const std::string& RaftConfig::workers(int index) const {
  // @@protoc_insertion_point(field_get:RaftConfig.workers)
  return _internal_workers(index);
}
inline std::string* RaftConfig::mutable_workers(int index) {
  // @@protoc_insertion_point(field_mutable:RaftConfig.workers)
  return workers_.Mutable(index);
}
inline void RaftConfig::set_workers(int index, const std::string& value) {
  workers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:RaftConfig.workers)
}
inline void RaftConfig::set_workers(int index, std::string&& value) {
  workers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:RaftConfig.workers)
}
inline void RaftConfig::set_workers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  workers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RaftConfig.workers)
}
inline void RaftConfig::set_workers(int index, const char* value, size_t size) {
  workers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RaftConfig.workers)
}
inline std::string* RaftConfig::_internal_add_workers() {
  return workers_.Add();
}
inline void RaftConfig::add_workers(const std::string& value) {
  workers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RaftConfig.workers)
}
inline void RaftConfig::add_workers(std::string&& value) {
  workers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RaftConfig.workers)
}
inline void RaftConfig::add_workers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  workers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RaftConfig.workers)
}
inline void RaftConfig::add_workers(const char* value, size_t size) {
  workers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RaftConfig.workers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RaftConfig::workers() const {
  // @@protoc_insertion_point(field_list:RaftConfig.workers)
  return workers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RaftConfig::mutable_workers() {
  // @@protoc_insertion_point(field_mutable_list:RaftConfig.workers)
  return &workers_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TaskStatus>() {
  return ::TaskStatus_descriptor();
}
template <> struct is_proto_enum< ::RaftCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RaftCommand>() {
  return ::RaftCommand_descriptor();
}
template <> struct is_proto_enum< ::UserStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UserStatus>() {
  return ::UserStatus_descriptor();
}
template <> struct is_proto_enum< ::UserCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UserCommand>() {
  return ::UserCommand_descriptor();
}
template <> struct is_proto_enum< ::WorkerStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WorkerStatus>() {
  return ::WorkerStatus_descriptor();
}
template <> struct is_proto_enum< ::WorkerCommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WorkerCommand>() {
  return ::WorkerCommand_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_abeille_2eproto
